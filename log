arch/sh/include/asm/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
arch/arm/mach-footbridge/netwinder-hw.c:static inline void rwa010_waveartist_init(int base, int irq, int dma)
arch/arm/mach-footbridge/netwinder-hw.c:	rwa010_waveartist_init(0x250, 3, 7);
arch/arm/mach-pxa/saar.c:	SMART_CMD(0x00),	/* wave ctrl */
arch/arm/mach-pxa/am200epd.c:	16kb waveform data | CRC | padding
arch/arm/mach-pxa/am200epd.c:	/* waveform must be 16k + 2 for checksum */
arch/arm/mach-s5pv210/cpu.c:	if (!(machine_is_herring() || machine_is_aries() || machine_is_wave() || machine_is_wave2()))
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= mach-wave.o wave-rfkill.o bigmem.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave-vibrator.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave-btlpm.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave-watchdog.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave-panel-tl2796.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave-panel-lg4573.o
arch/arm/mach-s5pv210/Makefile:obj-$(CONFIG_MACH_WAVE)	+= dev-wave-phone.o
arch/arm/mach-s5pv210/wave-panel-tl2796.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/wave-panel-tl2796.c:struct s5p_tl2796_panel_data wave_tl2796_panel_data = {
arch/arm/mach-s5pv210/wave-vibrator.c:/* arch/arm/mach-s5pv210/wave-vibrator.c
arch/arm/mach-s5pv210/wave-vibrator.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/wave-vibrator.c:static void wave_vibrator_off(void)
arch/arm/mach-s5pv210/wave-vibrator.c:static int wave_vibrator_get_time(struct timed_output_dev *dev)
arch/arm/mach-s5pv210/wave-vibrator.c:static void wave_vibrator_enable(struct timed_output_dev *dev, int value)
arch/arm/mach-s5pv210/wave-vibrator.c:		wave_vibrator_off();
arch/arm/mach-s5pv210/wave-vibrator.c:	.get_time	= wave_vibrator_get_time,
arch/arm/mach-s5pv210/wave-vibrator.c:	.enable		= wave_vibrator_enable,
arch/arm/mach-s5pv210/wave-vibrator.c:static enum hrtimer_restart wave_vibrator_timer_func(struct hrtimer *timer)
arch/arm/mach-s5pv210/wave-vibrator.c:static void wave_vibrator_work(struct work_struct *work)
arch/arm/mach-s5pv210/wave-vibrator.c:	wave_vibrator_off();
arch/arm/mach-s5pv210/wave-vibrator.c:static int __init wave_init_vibrator(void)
arch/arm/mach-s5pv210/wave-vibrator.c:	vibdata.timer.function = wave_vibrator_timer_func;
arch/arm/mach-s5pv210/wave-vibrator.c:	INIT_WORK(&vibdata.work, wave_vibrator_work);
arch/arm/mach-s5pv210/wave-vibrator.c:device_initcall(wave_init_vibrator);
arch/arm/mach-s5pv210/wave-btlpm.c:/* linux/arch/arm/mach-s5pv210/wave-btlpm.c
arch/arm/mach-s5pv210/wave-btlpm.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/wave-btlpm.c:#include "wave.h"
arch/arm/mach-s5pv210/wave-btlpm.c:static struct wave_bt_lpm {
arch/arm/mach-s5pv210/wave-btlpm.c:void wave_bt_uart_wake_peer(struct uart_port *port)
arch/arm/mach-s5pv210/wave-rfkill.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/wave-rfkill.c:#include "wave.h"
arch/arm/mach-s5pv210/wave-rfkill.c:static int __init wave_rfkill_probe(struct platform_device *pdev)
arch/arm/mach-s5pv210/wave-rfkill.c:static struct platform_driver wave_device_rfkill = {
arch/arm/mach-s5pv210/wave-rfkill.c:	.probe = wave_rfkill_probe,
arch/arm/mach-s5pv210/wave-rfkill.c:static int __init wave_rfkill_init(void)
arch/arm/mach-s5pv210/wave-rfkill.c:	rc = platform_driver_register(&wave_device_rfkill);
arch/arm/mach-s5pv210/wave-rfkill.c:module_init(wave_rfkill_init);
arch/arm/mach-s5pv210/wave-rfkill.c:MODULE_DESCRIPTION("wave rfkill");
arch/arm/mach-s5pv210/wave-watchdog.c:/* wave-watchdog.c
arch/arm/mach-s5pv210/dev-wave-phone.c:/* linux/arch/arm/mach-s5pv210/dev-wave-phone.c
arch/arm/mach-s5pv210/dev-wave-phone.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/dev-wave-phone.c:#include "../../../drivers/misc/samsung_modemctl/wave/modem_ctl.h"
arch/arm/mach-s5pv210/dev-wave-phone.c:static int __init wave_init_phone_interface(void)
arch/arm/mach-s5pv210/dev-wave-phone.c:device_initcall(wave_init_phone_interface);
arch/arm/mach-s5pv210/setup-sdhci.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/setup-sdhci.c:	if (machine_is_herring() || machine_is_aries() || machine_is_wave() || machine_is_wave2()) { /* TODO: move to mach-herring.c */
arch/arm/mach-s5pv210/setup-sdhci.c:	if (machine_is_aries() || machine_is_wave() || machine_is_wave2()) {
arch/arm/mach-s5pv210/setup-sdhci.c:	else if(machine_is_wave() || machine_is_wave2())
arch/arm/mach-s5pv210/setup-sdhci.c:	if (machine_is_herring() || machine_is_aries() || machine_is_wave() || machine_is_wave2()) {
arch/arm/mach-s5pv210/wave-panel-lg4573.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/wave-panel-lg4573.c:struct s5p_lg4573_panel_data wave_lg4573_panel_data = {
arch/arm/mach-s5pv210/wave.h: * arch/arm/mach-s5pv210/wave.h
arch/arm/mach-s5pv210/wave.h:void wave_bt_uart_wake_peer(struct uart_port *port);
arch/arm/mach-s5pv210/wave.h:extern struct s5p_tl2796_panel_data wave_tl2796_panel_data;
arch/arm/mach-s5pv210/wave.h:extern struct s5p_lg4573_panel_data wave_lg4573_panel_data;
arch/arm/mach-s5pv210/wave.h:extern struct s5p_tft_panel_data wave_tft_panel_data;
arch/arm/mach-s5pv210/wave.h:extern struct s5p_lcd_panel_data wave_lcd_panel_data;
arch/arm/mach-s5pv210/mach-wave.c:/* linux/arch/arm/mach-s5pv210/mach-wave.c
arch/arm/mach-s5pv210/mach-wave.c:#include <mach/gpio-wave.h>
arch/arm/mach-s5pv210/mach-wave.c:#include "wave.h"
arch/arm/mach-s5pv210/mach-wave.c:static int wave_notifier_call(struct notifier_block *this,
arch/arm/mach-s5pv210/mach-wave.c:static struct notifier_block wave_reboot_notifier = {
arch/arm/mach-s5pv210/mach-wave.c:	.notifier_call = wave_notifier_call,
arch/arm/mach-s5pv210/mach-wave.c:static void wave_switch_init(void)
arch/arm/mach-s5pv210/mach-wave.c:static struct s3c2410_uartcfg wave_uartcfgs[] __initdata = {
arch/arm/mach-s5pv210/mach-wave.c:		.wake_peer	= wave_bt_uart_wake_peer,
arch/arm/mach-s5pv210/mach-wave.c:static struct s5p_media_device wave_media_devs[] = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo2_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo3_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo4_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo5_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo7_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo8_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo9_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo11_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo12_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo13_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo14_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo15_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo16_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_ldo17_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_buck1_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_buck2_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_buck3_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct regulator_init_data wave_buck4_data = {
arch/arm/mach-s5pv210/mach-wave.c:static struct max8998_regulator_data wave_regulators[] = {
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO2,  &wave_ldo2_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO3,  &wave_ldo3_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO4,  &wave_ldo4_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO5,  &wave_ldo5_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO7,  &wave_ldo7_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO8,  &wave_ldo8_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO9,  &wave_ldo9_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO11, &wave_ldo11_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO12, &wave_ldo12_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO13, &wave_ldo13_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO14, &wave_ldo14_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO15, &wave_ldo15_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO16, &wave_ldo16_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_LDO17, &wave_ldo17_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_BUCK1, &wave_buck1_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_BUCK2, &wave_buck2_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_BUCK3, &wave_buck3_data },
arch/arm/mach-s5pv210/mach-wave.c:	{ MAX8998_BUCK4, &wave_buck4_data },
arch/arm/mach-s5pv210/mach-wave.c:static struct max8998_charger_data wave_charger = {
arch/arm/mach-s5pv210/mach-wave.c:	.num_regulators = ARRAY_SIZE(wave_regulators),
arch/arm/mach-s5pv210/mach-wave.c:	.regulators     = wave_regulators,
arch/arm/mach-s5pv210/mach-wave.c:	.charger        = &wave_charger,
arch/arm/mach-s5pv210/mach-wave.c:	if(machine_is_wave2()) {
arch/arm/mach-s5pv210/mach-wave.c:	if(machine_is_wave2()) {
arch/arm/mach-s5pv210/mach-wave.c:		.platform_data	= &wave_lg4573_panel_data,
arch/arm/mach-s5pv210/mach-wave.c:		.platform_data	= &wave_tl2796_panel_data,
arch/arm/mach-s5pv210/mach-wave.c:static struct spi_gpio_platform_data wave_display_spi_gpio_data = {
arch/arm/mach-s5pv210/mach-wave.c:		.platform_data	= &wave_display_spi_gpio_data,
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device wave_s3c_device_i2c4 = {
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device wave_s3c_device_i2c5 = {
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device wave_s3c_device_i2c6 = {
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device wave_s3c_device_i2c7 = {
arch/arm/mach-s5pv210/mach-wave.c:static struct gpio_keys_button wave_gpio_keys_table[] = {
arch/arm/mach-s5pv210/mach-wave.c:static struct gpio_keys_platform_data wave_gpio_keys_data = {
arch/arm/mach-s5pv210/mach-wave.c:	.buttons	= wave_gpio_keys_table,
arch/arm/mach-s5pv210/mach-wave.c:	.nbuttons	= ARRAY_SIZE(wave_gpio_keys_table),
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device wave_device_gpiokeys = {
arch/arm/mach-s5pv210/mach-wave.c:		.platform_data = &wave_gpio_keys_data,
arch/arm/mach-s5pv210/mach-wave.c:	if(machine_is_wave2())
arch/arm/mach-s5pv210/mach-wave.c:struct platform_device wave_charger_device = {
arch/arm/mach-s5pv210/mach-wave.c:	.name	= "wave_charger",
arch/arm/mach-s5pv210/mach-wave.c:static struct gpio_init_data wave_init_gpios[] = {
arch/arm/mach-s5pv210/mach-wave.c:	for (i = 0; i < ARRAY_SIZE(wave_init_gpios); i++) {
arch/arm/mach-s5pv210/mach-wave.c:		gpio = wave_init_gpios[i].num;
arch/arm/mach-s5pv210/mach-wave.c:		s3c_gpio_cfgpin(gpio, wave_init_gpios[i].cfg);
arch/arm/mach-s5pv210/mach-wave.c:		s3c_gpio_setpull(gpio, wave_init_gpios[i].pud);
arch/arm/mach-s5pv210/mach-wave.c:		if (wave_init_gpios[i].val != S3C_GPIO_SETPIN_NONE)
arch/arm/mach-s5pv210/mach-wave.c:			gpio_set_value(gpio, wave_init_gpios[i].val);
arch/arm/mach-s5pv210/mach-wave.c:		s3c_gpio_set_drvstrength(gpio, wave_init_gpios[i].drv);
arch/arm/mach-s5pv210/mach-wave.c:static void wave_power_off(void)
arch/arm/mach-s5pv210/mach-wave.c:static unsigned int wave_sleep_gpio_table[][3] = {
arch/arm/mach-s5pv210/mach-wave.c:static void *wave_mem_prealloc(int section, unsigned long size)
arch/arm/mach-s5pv210/mach-wave.c:int __init wave_init_wifi_mem(void)
arch/arm/mach-s5pv210/mach-wave.c:static cntry_locales_custom_t wave_wifi_translate_custom_table[] = {
arch/arm/mach-s5pv210/mach-wave.c:static void *wave_wifi_get_country_code(char *ccode)
arch/arm/mach-s5pv210/mach-wave.c:	int size = ARRAY_SIZE(wave_wifi_translate_custom_table);
arch/arm/mach-s5pv210/mach-wave.c:		if (strcmp(ccode, wave_wifi_translate_custom_table[i].iso_abbrev) == 0)
arch/arm/mach-s5pv210/mach-wave.c:			return &wave_wifi_translate_custom_table[i];
arch/arm/mach-s5pv210/mach-wave.c:	return &wave_wifi_translate_custom_table[0];
arch/arm/mach-s5pv210/mach-wave.c:	.mem_prealloc		= wave_mem_prealloc,
arch/arm/mach-s5pv210/mach-wave.c:	.get_country_code	= wave_wifi_get_country_code,
arch/arm/mach-s5pv210/mach-wave.c:static struct platform_device *wave_devices[] __initdata = {
arch/arm/mach-s5pv210/mach-wave.c:	//&wave_input_device,
arch/arm/mach-s5pv210/mach-wave.c:	&wave_device_gpiokeys,
arch/arm/mach-s5pv210/mach-wave.c:	&wave_s3c_device_i2c4,
arch/arm/mach-s5pv210/mach-wave.c:	&wave_s3c_device_i2c5,  /* accel sensor */
arch/arm/mach-s5pv210/mach-wave.c:	&wave_s3c_device_i2c6,
arch/arm/mach-s5pv210/mach-wave.c:	&wave_s3c_device_i2c7,
arch/arm/mach-s5pv210/mach-wave.c:	&wave_charger_device,
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[2].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_NOCAM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[4].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_NOCAM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[0].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_NOCAM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[1].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_NOCAM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[2].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0_BM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[4].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0_BM;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[0].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0_XL; 
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[1].memsize =  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1_XL;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[2].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[4].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[0].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0_XL; 
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[1].memsize =  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1_XL;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[2].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[4].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_FIMC0;
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[0].memsize = S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC0; 
arch/arm/mach-s5pv210/mach-wave.c:		wave_media_devs[1].memsize =  S5PV210_VIDEO_SAMSUNG_MEMSIZE_MFC1;
arch/arm/mach-s5pv210/mach-wave.c:static void __init wave_map_io(void)
arch/arm/mach-s5pv210/mach-wave.c:	s3c24xx_init_uarts(wave_uartcfgs, ARRAY_SIZE(wave_uartcfgs));
arch/arm/mach-s5pv210/mach-wave.c:	s5p_reserve_bootmem(wave_media_devs,
arch/arm/mach-s5pv210/mach-wave.c:		ARRAY_SIZE(wave_media_devs), S5P_RANGE_MFC);
arch/arm/mach-s5pv210/mach-wave.c:static void __init wave_fixup(struct machine_desc *desc,
arch/arm/mach-s5pv210/mach-wave.c:static void wave_init_gpio(void)
arch/arm/mach-s5pv210/mach-wave.c:	s3c_config_sleep_gpio_table(ARRAY_SIZE(wave_sleep_gpio_table),
arch/arm/mach-s5pv210/mach-wave.c:			wave_sleep_gpio_table);
arch/arm/mach-s5pv210/mach-wave.c:static void wave_pm_restart(char mode, const char *cmd)
arch/arm/mach-s5pv210/mach-wave.c:static void __init wave_inject_cmdline(void) {
arch/arm/mach-s5pv210/mach-wave.c:static uint32_t wave_keymap[] __initdata = {
arch/arm/mach-s5pv210/mach-wave.c:static struct matrix_keymap_data wave_keymap_data __initdata = {
arch/arm/mach-s5pv210/mach-wave.c:	.keymap		= wave_keymap,
arch/arm/mach-s5pv210/mach-wave.c:	.keymap_size	= ARRAY_SIZE(wave_keymap),
arch/arm/mach-s5pv210/mach-wave.c:static struct samsung_keypad_platdata wave_keypad_data __initdata = {
arch/arm/mach-s5pv210/mach-wave.c:	.keymap_data	= &wave_keymap_data,
arch/arm/mach-s5pv210/mach-wave.c:static void __init wave_machine_init(void)
arch/arm/mach-s5pv210/mach-wave.c:	arm_pm_restart = wave_pm_restart;
arch/arm/mach-s5pv210/mach-wave.c:	wave_inject_cmdline();
arch/arm/mach-s5pv210/mach-wave.c:	platform_add_devices(wave_devices, ARRAY_SIZE(wave_devices));
arch/arm/mach-s5pv210/mach-wave.c:	pm_power_off = wave_power_off ;
arch/arm/mach-s5pv210/mach-wave.c:	wave_init_gpio();
arch/arm/mach-s5pv210/mach-wave.c:	samsung_keypad_set_platdata(&wave_keypad_data);
arch/arm/mach-s5pv210/mach-wave.c:	if(machine_is_wave()) {
arch/arm/mach-s5pv210/mach-wave.c:	if(machine_is_wave2()) {
arch/arm/mach-s5pv210/mach-wave.c:	register_reboot_notifier(&wave_reboot_notifier);
arch/arm/mach-s5pv210/mach-wave.c:	wave_switch_init();
arch/arm/mach-s5pv210/mach-wave.c:	wave_init_wifi_mem();
arch/arm/mach-s5pv210/mach-wave.c:MACHINE_START(WAVE, "wave")
arch/arm/mach-s5pv210/mach-wave.c:	.fixup		= wave_fixup,
arch/arm/mach-s5pv210/mach-wave.c:	.map_io		= wave_map_io,
arch/arm/mach-s5pv210/mach-wave.c:	.init_machine	= wave_machine_init,
arch/arm/mach-s5pv210/mach-wave.c:MACHINE_START(WAVE2, "wave2")
arch/arm/mach-s5pv210/mach-wave.c:	.fixup		= wave_fixup,
arch/arm/mach-s5pv210/mach-wave.c:	.map_io		= wave_map_io,
arch/arm/mach-s5pv210/mach-wave.c:	.init_machine	= wave_machine_init,
arch/arm/configs/cyanogenmod_wavesd_defconfig:CONFIG_INITRAMFS_SOURCE="usr/wavenand_initramfs_files"
arch/arm/tools/mach-types:esl_wave_a		MACH_ESL_WAVE_A		ESL_WAVE_A		2904
arch/arm/tools/mach-types:esl_wave_b		MACH_ESL_WAVE_B		ESL_WAVE_B		2905
arch/arm/tools/mach-types:premierwave_en		MACH_PREMIERWAVE_EN	PREMIERWAVE_EN		2985
arch/arm/tools/mach-types:wave			MACH_WAVE		WAVE			8500
arch/arm/tools/mach-types:wave2			MACH_WAVE		WAVE2			8530
arch/arm/mach-sa1100/cpu-sa1100.c: *   MDCAS0    0xA0000004    Access waveform
arch/arm/mach-sa1100/cpu-sa1100.c: *   MDCAS1    0xA0000008    Access waveform
arch/arm/mach-sa1100/cpu-sa1100.c: *   MDCAS2    0xA000000C    Access waveform
arch/m68k/mac/macboing.c: * dumb triangular wave table
arch/m68k/mac/macboing.c:static __u8 mac_asc_wave_tab[ 0x800 ];
arch/m68k/mac/macboing.c:static unsigned long mac_bell_phase; /* 0..2*Pi -> 0..0x800 (wavetable size) */
arch/m68k/mac/macboing.c:	 * init the wave table with a simple triangular wave
arch/m68k/mac/macboing.c:	 * A sine wave would sure be nicer here ...
arch/m68k/mac/macboing.c:		mac_asc_wave_tab[ i ] = i / 4;
arch/m68k/mac/macboing.c:		mac_asc_wave_tab[ i + 0x400 ] = 0xFF - i / 4;
arch/m68k/mac/macboing.c:		mac_asc_regs[ i ] = mac_asc_wave_tab[ i ];
arch/m68k/mac/macboing.c: * EASC entry; init EASC, don't load wavetable, schedule 'start whining'.
arch/m68k/mac/macboing.c:	mac_bell_phasepersample = ( freq * sizeof( mac_asc_wave_tab ) ) / mac_asc_samplespersec;
arch/m68k/mac/macboing.c: * already load the wave table, or at least call this one...
arch/m68k/mac/macboing.c: * This piece keeps reloading the wave table until done.
arch/m68k/mac/macboing.c:			mac_asc_regs[ 0 ] = mac_asc_wave_tab[ mac_bell_phase & ( sizeof( mac_asc_wave_tab ) - 1 ) ];
arch/m68k/include/asm/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
arch/mips/sibyte/swarm/rtc_m41t81.c:#define M41T81REG_AMO_SQWE	0x40		/* square wave enable */
arch/mips/sibyte/swarm/rtc_m41t81.c:#define M41T81REG_SQW	0x13		/* square wave register */
arch/mips/sgi-ip22/ip22-eisa.c:	   Please wave your favorite dead chicken over the busses */
arch/mips/powertv/powertv-usb.c: * usb_eye_configure - for optimizing the shape USB eye waveform
arch/mips/include/asm/sgi/ioc.h:#define SGINT_TCWORD_MSWGEN	0x06	/* Square wave generator mode */
arch/parisc/kernel/hardware.c:	{HPHW_NPROC,0x5D8,0x4,0x91,"Rhapsody wave 2 W+ DC-"},
arch/parisc/kernel/hardware.c:	{HPHW_NPROC,0x5D9,0x4,0x91,"Rhapsody wave 2 W+"},
arch/parisc/include/asm/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
arch/blackfin/mach-bf561/include/mach/anomaly.h:/* In PWM_OUT mode, you must enable the PPI block to generate a waveform from PPI_CLK */
arch/blackfin/mach-bf533/include/mach/anomaly.h:/* In PWM_OUT mode, you must enable the PPI block to generate a waveform from PPI_CLK */
arch/x86/kernel/acpi/realmode/wakemain.c:		outb(0xb6, 0x43);	/* Ctr 2, squarewave, load, binary */
arch/powerpc/platforms/85xx/p1022_ds.c: * @pixclock: the wavelength, in picoseconds, of the clock
arch/powerpc/platforms/85xx/p1022_ds.c:	/* Convert pixclock from a wavelength to a frequency */
arch/powerpc/include/asm/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
build.sh:export CROSS_COMPILE=/home/demo/VidÃ©os/wave_sd/toolchain/bin/arm-linux-gnueabihf-
build.sh:make cyanogenmod_wavesd_defconfig
Documentation/input/ff.txt:- FF_PERIODIC	can render periodic effects with the following waveforms:
Documentation/input/ff.txt:  - FF_SQUARE	  square waveform
Documentation/input/ff.txt:  - FF_TRIANGLE	  triangle waveform
Documentation/input/ff.txt:  - FF_SINE	  sine waveform
Documentation/input/ff.txt:  - FF_SAW_UP	  sawtooth up waveform
Documentation/input/ff.txt:  - FF_SAW_DOWN	  sawtooth down waveform
Documentation/input/ff.txt:  - FF_CUSTOM	  custom waveform
Documentation/networking/multicast.txt:wavelan		YES		PROMISC		YES		Hardware
Documentation/dvb/cards.txt:   - nxt200x		: Nxtwave NXT2002 & NXT2004
Documentation/devices.txt:		145 = /dev/hfmodem	Soundcard shortwave modem control
Documentation/devices.txt:		219 = /dev/modems/mwave	MWave modem firmware upload
Documentation/video4linux/ov511.txt:	appearance of "banding", i.e. horizontal lines or waves of light and
Documentation/sound/alsa/alsa-parameters.txt:	snd-interwave=	[HW,ALSA]
Documentation/sound/alsa/alsa-parameters.txt:	snd-interwave-stb=
Documentation/sound/alsa/alsa-parameters.txt:	snd-wavefront=	[HW,ALSA]
Documentation/sound/alsa/CMIPCI.txt:There is _no_ hardware wavetable function on this chip (except for
Documentation/sound/alsa/ALSA-Configuration.txt:    EQ, mpu401, gameport. A3D and wavetable support are still in development.
Documentation/sound/alsa/ALSA-Configuration.txt:    max_synth_voices - limit of voices used for wavetable (64 by default)
Documentation/sound/alsa/ALSA-Configuration.txt:    max_buffer_size  - specifies the maximum size of wavetable/pcm buffers
Documentation/sound/alsa/ALSA-Configuration.txt:  Module snd-interwave
Documentation/sound/alsa/ALSA-Configuration.txt:  Module snd-interwave-stb
Documentation/sound/alsa/ALSA-Configuration.txt:  Module snd-wavefront
Documentation/sound/alsa/ALSA-Configuration.txt:    The below are options for wavefront_synth features:
Documentation/sound/alsa/ALSA-Configuration.txt:		      (default:wavefront.os)
Documentation/sound/alsa/ALSA-Configuration.txt:    Note: the firmware file "wavefront.os" was located in the earlier
Documentation/sound/alsa/ALSA-Configuration.txt:			* CHIC  True Sound 4Dwave
Documentation/sound/alsa/ALSA-Configuration.txt:    wavetable_size - max wavetable size in kB (4-?kb)
Documentation/sound/alsa/ALSA-Configuration.txt:alias snd-card-0 snd-interwave
Documentation/sound/alsa/ALSA-Configuration.txt:options snd-interwave index=0
Documentation/sound/alsa/ALSA-Configuration.txt:alias sound-slot-0 snd-interwave
Documentation/sound/alsa/ALSA-Configuration.txt:In this example, the interwave card is always loaded as the first card
Documentation/sound/alsa/ALSA-Configuration.txt:options snd slots=snd-interwave,snd-ens1371
Documentation/sound/alsa/ALSA-Configuration.txt:Then, the first slot (#0) is reserved for snd-interwave driver, and
Documentation/sound/alsa/ALSA-Configuration.txt:other driver (e.g. snd-usb-audio) is loaded before snd-interwave or
Documentation/sound/oss/WaveArtist: 0e | 0 | left wavetable channel volume                                               |
Documentation/sound/oss/WaveArtist: 0f | 0 | right wavetable channel volume                                              |
Documentation/sound/oss/README.OSS:		for information about using the wave table synth.
Documentation/sound/oss/README.OSS:	a wave table synthesizer packed onto the same chip. The driver supports
Documentation/sound/oss/README.OSS:	SoftOSS is a software based wave table emulation which works with
Documentation/sound/oss/README.OSS:	SoftOSS implements the wave table API originally designed for GUS. For
Documentation/sound/oss/README.OSS:a MV Jazz based card which has an additional OPL4 based wave table
Documentation/sound/oss/README.OSS:through toggleing the record button for the wave controller with an
Documentation/sound/oss/README.OSS:Sierra Aria and IBM Mwave. It's possible that these architectures
Documentation/sound/oss/Tropez+:  alias char-major-14 wavefront
Documentation/sound/oss/Tropez+:  alias synth0 wavefront
Documentation/sound/oss/Tropez+:  pre-install wavefront modprobe "-k" "cs4232"
Documentation/sound/oss/Tropez+:  post-install wavefront modprobe "-k" "opl3"
Documentation/sound/oss/Tropez+:  options wavefront io=0x200 irq=9
Documentation/sound/oss/Tropez+:       the wavefront options "io" and "irq" ***MUST*** match the "synthio"
Documentation/sound/oss/Tropez+:Please see drivers/sound/README.wavefront for more details.
Documentation/sound/oss/oss-parameters.txt:	waveartist=	[HW,OSS]
Documentation/sound/oss/vwsnd:as wavetable).  PCM input and output can be mono or stereo in any of
Documentation/sound/oss/Soundblaster:mwave_bug=1	Set if you are trying to use this driver with mwave (see on)
Documentation/sound/oss/Soundblaster:Using Mwave
Documentation/sound/oss/Soundblaster:To make this driver work with Mwave you must set mwave_bug. You also need
Documentation/sound/oss/ultrasound:no_wave_dma	Set to disable DMA usage for wavetable (see note)
Documentation/sound/oss/ultrasound:no_wave_dma option
Documentation/sound/oss/ultrasound:This option defaults to a value of 0, which allows the Ultrasound wavetable
Documentation/sound/oss/ultrasound:(/dev/dsp), MIDI, and wavetable playback.
Documentation/sound/oss/mwave:	How to try to survive an IBM Mwave under Linux SB drivers
Documentation/sound/oss/mwave:	trying to make the Mwave work. This is not however a trivial task.
Documentation/sound/oss/mwave:REM See the Mwave README file for instructions.
Documentation/virtual/kvm/timekeeping.txt:Mode 3: Square Wave.   This generates a high / low square wave.  The count
Documentation/virtual/kvm/timekeeping.txt: which generates sine-like tones by low-pass filtering the square wave output.
Documentation/virtual/kvm/timekeeping.txt:                       bit 3   = Square wave interrupt enable
Documentation/blackfin/gptimers-example.c:	/* read the width/period values that were captured for the waveform */
Documentation/ioctl/ioctl-number.txt:0x00	00-1F	linux/wavefront.h	conflict!
Documentation/ioctl/ioctl-number.txt:0xDB	00-0F	drivers/char/mwave/mwavepub.h
Documentation/DocBook/writing-an-alsa-driver.tmpl:      wavetable PCM. 
Documentation/fb/metronomefb.txt:Metronomefb requires waveform information which is delivered via the AMLCD
Documentation/fb/metronomefb.txt:interface to the metronome controller. The waveform information is expected to
Documentation/fb/metronomefb.txt:be delivered from userspace via the firmware class interface. The waveform file
Documentation/fb/metronomefb.txt:udev/hotplug setup. I have only tested with a single waveform file which was
Documentation/fb/metronomefb.txt:Caution should be exercised when manipulating the waveform as there may be
Documentation/fb/metronomefb.txt:I neither have access to nor know exactly what the waveform does in terms of
Documentation/devicetree/bindings/net/can/fsl-flexcan.txt:	time quantum used to compose the CAN waveform.
drivers/input/input-compat.h:	__u16 waveform;
drivers/input/input-compat.c:		    compat_effect->u.periodic.waveform == FF_CUSTOM)
drivers/input/joystick/iforce/iforce-ff.c:	u8 wave_code;
drivers/input/joystick/iforce/iforce-ff.c:	switch (effect->u.periodic.waveform) {
drivers/input/joystick/iforce/iforce-ff.c:		case FF_SQUARE:		wave_code = 0x20; break;
drivers/input/joystick/iforce/iforce-ff.c:		case FF_TRIANGLE:	wave_code = 0x21; break;
drivers/input/joystick/iforce/iforce-ff.c:		case FF_SINE:		wave_code = 0x22; break;
drivers/input/joystick/iforce/iforce-ff.c:		case FF_SAW_UP:		wave_code = 0x23; break;
drivers/input/joystick/iforce/iforce-ff.c:		case FF_SAW_DOWN:	wave_code = 0x24; break;
drivers/input/joystick/iforce/iforce-ff.c:		default:		wave_code = 0x20; break;
drivers/input/joystick/iforce/iforce-ff.c:			wave_code,
drivers/input/serio/Kconfig:	  clock, a basic audio waveform generator, and an HP-HIL Master
drivers/input/ff-core.c:		e1->u.periodic.waveform == e2->u.periodic.waveform);
drivers/input/ff-core.c:		 * calculate manginude of sine wave as average of rumble's
drivers/input/ff-core.c:		effect->u.periodic.waveform = FF_SINE;
drivers/input/ff-core.c:	    (effect->u.periodic.waveform < FF_WAVEFORM_MIN ||
drivers/input/ff-core.c:	     effect->u.periodic.waveform > FF_WAVEFORM_MAX ||
drivers/input/ff-core.c:	     !test_bit(effect->u.periodic.waveform, dev->ffbit))) {
drivers/input/ff-core.c:		pr_debug("invalid or not supported wave form in upload\n");
drivers/input/misc/hp_sdc_rtc.c:                     "square_wave\t: %s\n"
drivers/input/misc/uinput.c:	 * custom waveform since it does not have a way to pass buffer of
drivers/input/misc/uinput.c:	 * supporting custom waveforms we would need to define an additional
drivers/input/misc/uinput.c:			effect->u.periodic.waveform == FF_CUSTOM)
drivers/input/misc/uinput.c:		 * custom waveforms in uinput anyway we can just copy the whole
drivers/power/Makefile:obj-$(CONFIG_CHARGER_WAVE) += wave_charger.o
drivers/power/wave_charger.c: * linux/drivers/power/wave_charger.c
drivers/power/wave_charger.c:#include <mach/gpio-wave.h>
drivers/power/wave_charger.c:#define DRIVER_NAME	"wave_charger"
drivers/power/s5pc110_battery.c:#include <mach/gpio-wave.h>
drivers/net/wireless/rtlwifi/rtl8192cu/sw.c:	{RTL_USB_DEVICE(0x3358, 0x13d3, rtl92cu_hal_cfg)}, /*Azwave 8188CE-VAU*/
drivers/net/wireless/rtlwifi/rtl8192cu/sw.c:	/* Russian customer -Azwave (8188CE-VAU  b/g mode only) */
drivers/net/wireless/ath/ath9k/hif_usb.c:	{ USB_DEVICE(0x13D3, 0x3327) }, /* Azurewave */
drivers/net/wireless/ath/ath9k/hif_usb.c:	{ USB_DEVICE(0x13D3, 0x3328) }, /* Azurewave */
drivers/net/wireless/ath/ath9k/hif_usb.c:	{ USB_DEVICE(0x13D3, 0x3348) }, /* Azurewave */
drivers/net/wireless/ath/ath9k/hif_usb.c:	{ USB_DEVICE(0x13D3, 0x3349) }, /* Azurewave */
drivers/net/wireless/ath/ath9k/hif_usb.c:	{ USB_DEVICE(0x13D3, 0x3350) }, /* Azurewave */
drivers/net/wireless/ath/ath9k/ani.c: * your signal completely if phase is 180 degrees (think of adding sine waves).
drivers/net/wireless/b43/lo.c:  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/phy_a.c:  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/leds.c:  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/phy_common.c:  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/phy_g.c:  Copyright (c) 2005, 2006 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/main.c:  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/xmit.c:  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/tables.c:  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43/main.h:                     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/rt2x00/rt2800usb.c:	/* Azurewave */
drivers/net/wireless/b43legacy/radio.c:		     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/leds.c:  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/phy.h:		     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/phy.c:     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/main.c: *  Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/xmit.c:  Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/radio.h:		     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/ilt.c:		     Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/wireless/b43legacy/main.h:  Copyright (c) 2005  Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/net/sungem.h: * MDC clock waveform on the MII Management Interface when the MIF is
drivers/net/znet.c:   Some code was taken from wavelan_cs.
drivers/net/wan/lmc/lmc_ioctl.h:#define LMC_MII16_T1_ONESEC             0x0040  /* one second square wave - ro */
drivers/net/mlx4/fw.h:	u16 wavelength[MLX4_MAX_PORTS + 1];
drivers/net/mlx4/fw.c:			MLX4_GET(dev_cap->wavelength[i], outbox, QUERY_PORT_WAVELENGTH_OFFSET);
drivers/net/mlx4/main.c:		dev->caps.wavelength[i]     = dev_cap->wavelength[i];
drivers/usb/serial/cp210x.c:	{ USB_DEVICE(0x10C4, 0x815F) }, /* Timewave HamLinkUSB */
drivers/usb/serial/cp210x.c:	{ USB_DEVICE(0x10C4, 0xF002) }, /* Elan Digital Systems USBwave12 */
drivers/mtd/onenand/samsung.c:#include "samsung_wave.h"
drivers/mtd/onenand/samsung.c:		if(machine_is_wave2()) {
drivers/mtd/onenand/samsung.c:			num_partitions = ARRAY_SIZE(wave_s8530_partition_info);	/* pdata->nr_parts */
drivers/mtd/onenand/samsung.c:			partitions = wave_s8530_partition_info;			/* pdata->parts */
drivers/mtd/onenand/samsung.c:			num_partitions = ARRAY_SIZE(wave_s8500_partition_info);	/* pdata->nr_parts */
drivers/mtd/onenand/samsung.c:			partitions = wave_s8500_partition_info;			/* pdata->parts */
drivers/mtd/onenand/samsung_wave.h:/* linux/drivers/mtd/onenand/samsung_wave.h
drivers/mtd/onenand/samsung_wave.h:struct mtd_partition wave_s8500_partition_info[] = {
drivers/mtd/onenand/samsung_wave.h:struct mtd_partition wave_s8530_partition_info[] = {
drivers/char/Kconfig:	tristate "ACP Modem (Mwave) support"
drivers/char/Kconfig:	  The ACP modem (Mwave) for Linux is a WinModem. It is composed of a
drivers/char/Kconfig:	  If you own one of the above IBM Thinkpads which has the Mwave chipset
drivers/char/Kconfig:	  module will be called mwave.
drivers/char/Makefile:obj-$(CONFIG_MWAVE)		+= mwave/
drivers/char/genrtc.c:		     "square_wave\t: %s\n"
drivers/char/rtc.c:		   "square_wave\t: %s\n"
drivers/char/mwave/mwavedd.h:* mwavedd.h -- declarations for mwave device driver
drivers/char/mwave/mwavedd.h:#include "mwavepub.h"
drivers/char/mwave/mwavedd.h:extern int mwave_debug;
drivers/char/mwave/mwavedd.h:extern int mwave_3780i_irq;
drivers/char/mwave/mwavedd.h:extern int mwave_3780i_io;
drivers/char/mwave/mwavedd.h:extern int mwave_uart_irq;
drivers/char/mwave/mwavedd.h:extern int mwave_uart_io;
drivers/char/mwave/mwavedd.h:#define KERN_ERR_MWAVE KERN_ERR "mwave: "
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:  if (f & (mwave_debug)) {                  \
drivers/char/mwave/mwavedd.h:	BOOLEAN bMwaveDevRegistered;
drivers/char/mwave/mwavedd.h:extern MWAVE_DEVICE_DATA mwave_s_mdd;
drivers/char/mwave/3780i.c:#include "mwavedd.h"
drivers/char/mwave/Makefile:# Makefile for ACP Modem (Mwave).
drivers/char/mwave/Makefile:obj-$(CONFIG_MWAVE) += mwave.o
drivers/char/mwave/Makefile:mwave-y := mwavedd.o smapi.o tp3780i.o 3780i.o
drivers/char/mwave/Makefile:# To have the mwave driver disable other uarts if necessary
drivers/char/mwave/README:The mwave module takes the following options.  Note that these options
drivers/char/mwave/README:  mwave_debug=value, where value is bitwise OR of trace flags:
drivers/char/mwave/README:	0x0001 mwavedd api tracing
drivers/char/mwave/README:  mwave_3780i_irq=5/7/10/11/15
drivers/char/mwave/README:  mwave_3780i_io=0x130/0x350/0x0070/0xDB0
drivers/char/mwave/README:  mwave_uart_irq=3/4
drivers/char/mwave/README:	If the mwave's uart irq has not been setup and stored in bios by the 
drivers/char/mwave/README:	irq used by the mwave uart to be configured.
drivers/char/mwave/README:  mwave_uart_io=0x3f8/0x2f8/0x3E8/0x2E8
drivers/char/mwave/README:	io range used by the mwave uart to be configured.
drivers/char/mwave/README:  insmod mwave mwave_3780i_irq=10 mwave_3780i_io=0x0130 mwave_uart_irq=3 mwave_uart_io=0x2f8
drivers/char/mwave/README:  mknod --mode=660 /dev/modems/mwave c 10 219
drivers/char/mwave/tp3780i.c:#include "mwavedd.h"
drivers/char/mwave/tp3780i.c:#include "mwavepub.h"
drivers/char/mwave/tp3780i.c:	pMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;
drivers/char/mwave/tp3780i.c:		if (mwave_3780i_irq || mwave_3780i_io || mwave_uart_irq || mwave_uart_io) {
drivers/char/mwave/tp3780i.c:	pres = request_region(pSettings->usDspBaseIO, 16, "mwave_3780i");
drivers/char/mwave/tp3780i.c:	if (request_irq(pSettings->usUartIrq, &UartInterrupt, 0, "mwave_uart", NULL)) {
drivers/char/mwave/tp3780i.c:	if (request_irq(pSettings->usDspIrq, &DspInterrupt, 0, "mwave_3780i", NULL)) {
drivers/char/mwave/tp3780i.c:	/* Fill out Mwave OS and BIOS task names */
drivers/char/mwave/tp3780i.c:	memcpy(pAbilities->mwave_os_name, TP_ABILITIES_MWAVEOS_NAME,
drivers/char/mwave/mwavedd.c:* mwavedd.c -- mwave device driver
drivers/char/mwave/mwavedd.c:#include "mwavedd.h"
drivers/char/mwave/mwavedd.c:MODULE_DESCRIPTION("3780i Advanced Communications Processor (Mwave) driver");
drivers/char/mwave/mwavedd.c:static DEFINE_MUTEX(mwave_mutex);
drivers/char/mwave/mwavedd.c:int mwave_debug = 0;
drivers/char/mwave/mwavedd.c:int mwave_3780i_irq = 0;
drivers/char/mwave/mwavedd.c:int mwave_3780i_io = 0;
drivers/char/mwave/mwavedd.c:int mwave_uart_irq = 0;
drivers/char/mwave/mwavedd.c:int mwave_uart_io = 0;
drivers/char/mwave/mwavedd.c:module_param(mwave_debug, int, 0);
drivers/char/mwave/mwavedd.c:module_param(mwave_3780i_irq, int, 0);
drivers/char/mwave/mwavedd.c:module_param(mwave_3780i_io, int, 0);
drivers/char/mwave/mwavedd.c:module_param(mwave_uart_irq, int, 0);
drivers/char/mwave/mwavedd.c:module_param(mwave_uart_io, int, 0);
drivers/char/mwave/mwavedd.c:static int mwave_open(struct inode *inode, struct file *file);
drivers/char/mwave/mwavedd.c:static int mwave_close(struct inode *inode, struct file *file);
drivers/char/mwave/mwavedd.c:static long mwave_ioctl(struct file *filp, unsigned int iocmd,
drivers/char/mwave/mwavedd.c:MWAVE_DEVICE_DATA mwave_s_mdd;
drivers/char/mwave/mwavedd.c:static int mwave_open(struct inode *inode, struct file *file)
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_open, entry inode %p file %p\n",
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_open, exit return retval %x\n", retval);
drivers/char/mwave/mwavedd.c:static int mwave_close(struct inode *inode, struct file *file)
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_close, entry inode %p file %p\n",
drivers/char/mwave/mwavedd.c:	PRINTK_2(TRACE_MWAVE, "mwavedd::mwave_close, exit retval %x\n",
drivers/char/mwave/mwavedd.c:static long mwave_ioctl(struct file *file, unsigned int iocmd,
drivers/char/mwave/mwavedd.c:	pMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_ioctl, entry file %p cmd %x arg %x\n",
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_RESET"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_RESET"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_RUN"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_RUN"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl,"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl, IOCTL_MW_DSP_ABILITIES"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_READ_DATA,"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_READ_INST,"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_WRITE_DATA,"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_WRITE_INST,"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:						"mwavedd::mwave_ioctl:"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_REGISTER_IPC"
drivers/char/mwave/mwavedd.c:						"mwavedd::mwave_ioctl:"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:					"mwavedd::mwave_ioctl, thread for"
drivers/char/mwave/mwavedd.c:						"mwavedd::mwave_ioctl"
drivers/char/mwave/mwavedd.c:						"mwavedd::mwave_ioctl"
drivers/char/mwave/mwavedd.c:					"mwavedd::mwave_ioctl IOCTL_MW_GET_IPC,"
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_ioctl IOCTL_MW_UNREGISTER_IPC"
drivers/char/mwave/mwavedd.c:						"mwavedd::mwave_ioctl:"
drivers/char/mwave/mwavedd.c:			mutex_lock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:			mutex_unlock(&mwave_mutex);
drivers/char/mwave/mwavedd.c:	PRINTK_2(TRACE_MWAVE, "mwavedd::mwave_ioctl, exit retval %x\n", retval);
drivers/char/mwave/mwavedd.c:static ssize_t mwave_read(struct file *file, char __user *buf, size_t count,
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_read entry file %p, buf %p, count %zx ppos %p\n",
drivers/char/mwave/mwavedd.c:static ssize_t mwave_write(struct file *file, const char __user *buf,
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_write entry file %p, buf %p,"
drivers/char/mwave/mwavedd.c:					"mwavedd::register_serial_portandirq:"
drivers/char/mwave/mwavedd.c:					"mwavedd::register_serial_portandirq:"
drivers/char/mwave/mwavedd.c:static const struct file_operations mwave_fops = {
drivers/char/mwave/mwavedd.c:	.read		= mwave_read,
drivers/char/mwave/mwavedd.c:	.write		= mwave_write,
drivers/char/mwave/mwavedd.c:	.unlocked_ioctl	= mwave_ioctl,
drivers/char/mwave/mwavedd.c:	.open		= mwave_open,
drivers/char/mwave/mwavedd.c:	.release	= mwave_close,
drivers/char/mwave/mwavedd.c:static struct miscdevice mwave_misc_dev = { MWAVE_MINOR, "mwave", &mwave_fops };
drivers/char/mwave/mwavedd.c:struct device mwave_device;
drivers/char/mwave/mwavedd.c:/* Prevent code redundancy, create a macro for mwave_show_* functions. */
drivers/char/mwave/mwavedd.c:#define mwave_show_function(attr_name, format_string, field)		\
drivers/char/mwave/mwavedd.c:static ssize_t mwave_show_##attr_name(struct device *dev, struct device_attribute *attr, char *buf)	\
drivers/char/mwave/mwavedd.c:		&mwave_s_mdd.rBDData.rDspSettings;			\
drivers/char/mwave/mwavedd.c:#define mwave_dev_rd_attr(attr_name, format_string, field)		\
drivers/char/mwave/mwavedd.c:	mwave_show_function(attr_name, format_string, field)		\
drivers/char/mwave/mwavedd.c:static DEVICE_ATTR(attr_name, S_IRUGO, mwave_show_##attr_name, NULL)
drivers/char/mwave/mwavedd.c:mwave_dev_rd_attr (3780i_dma, "%i\n", usDspDma);
drivers/char/mwave/mwavedd.c:mwave_dev_rd_attr (3780i_irq, "%i\n", usDspIrq);
drivers/char/mwave/mwavedd.c:mwave_dev_rd_attr (3780i_io, "%#.4x\n", usDspBaseIO);
drivers/char/mwave/mwavedd.c:mwave_dev_rd_attr (uart_irq, "%i\n", usUartIrq);
drivers/char/mwave/mwavedd.c:mwave_dev_rd_attr (uart_io, "%#.4x\n", usUartBaseIO);
drivers/char/mwave/mwavedd.c:static struct device_attribute * const mwave_dev_attrs[] = {
drivers/char/mwave/mwavedd.c:* mwave_init is called on module load
drivers/char/mwave/mwavedd.c:* mwave_exit is called on module unload
drivers/char/mwave/mwavedd.c:* mwave_exit is also used to clean up after an aborted mwave_init
drivers/char/mwave/mwavedd.c:static void mwave_exit(void)
drivers/char/mwave/mwavedd.c:	pMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;
drivers/char/mwave/mwavedd.c:	PRINTK_1(TRACE_MWAVE, "mwavedd::mwave_exit entry\n");
drivers/char/mwave/mwavedd.c:		device_remove_file(&mwave_device, mwave_dev_attrs[i]);
drivers/char/mwave/mwavedd.c:		device_unregister(&mwave_device);
drivers/char/mwave/mwavedd.c:	if (pDrvData->bMwaveDevRegistered) {
drivers/char/mwave/mwavedd.c:		misc_deregister(&mwave_misc_dev);
drivers/char/mwave/mwavedd.c:	PRINTK_1(TRACE_MWAVE, "mwavedd::mwave_exit exit\n");
drivers/char/mwave/mwavedd.c:module_exit(mwave_exit);
drivers/char/mwave/mwavedd.c:static int __init mwave_init(void)
drivers/char/mwave/mwavedd.c:	pMWAVE_DEVICE_DATA pDrvData = &mwave_s_mdd;
drivers/char/mwave/mwavedd.c:	PRINTK_1(TRACE_MWAVE, "mwavedd::mwave_init entry\n");
drivers/char/mwave/mwavedd.c:	memset(&mwave_s_mdd, 0, sizeof(MWAVE_DEVICE_DATA));
drivers/char/mwave/mwavedd.c:	pDrvData->bMwaveDevRegistered = FALSE;
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_init, return from tp3780I_InitializeBoardData"
drivers/char/mwave/mwavedd.c:				"mwavedd::mwave_init: Error:"
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_init, return from tp3780I_CalcResources"
drivers/char/mwave/mwavedd.c:				"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_init, return from tp3780I_ClaimResources"
drivers/char/mwave/mwavedd.c:				"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:		"mwavedd::mwave_init, return from tp3780I_EnableDSP"
drivers/char/mwave/mwavedd.c:				"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:	if (misc_register(&mwave_misc_dev) < 0) {
drivers/char/mwave/mwavedd.c:				"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:	pDrvData->bMwaveDevRegistered = TRUE;
drivers/char/mwave/mwavedd.c:				"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:	memset(&mwave_device, 0, sizeof (struct device));
drivers/char/mwave/mwavedd.c:	dev_set_name(&mwave_device, "mwave");
drivers/char/mwave/mwavedd.c:	if (device_register(&mwave_device))
drivers/char/mwave/mwavedd.c:	for (i = 0; i < ARRAY_SIZE(mwave_dev_attrs); i++) {
drivers/char/mwave/mwavedd.c:		if(device_create_file(&mwave_device, mwave_dev_attrs[i])) {
drivers/char/mwave/mwavedd.c:					"mwavedd:mwave_init: Error:"
drivers/char/mwave/mwavedd.c:					mwave_dev_attrs[i]->attr.name);
drivers/char/mwave/mwavedd.c:			"mwavedd::mwave_init: Error:"
drivers/char/mwave/mwavedd.c:	mwave_exit(); /* clean up */
drivers/char/mwave/mwavedd.c:module_init(mwave_init);
drivers/char/mwave/tp3780i.h:#include "mwavepub.h"
drivers/char/mwave/tp3780i.h:#define TP_ABILITIES_MWAVEOS_NAME       "mwaveos0700.dsp"
drivers/char/mwave/smapi.c:#include "mwavedd.h"
drivers/char/mwave/smapi.c:		"smapi::smapi_set_DSP_cfg entry mwave_3780i_irq %x mwave_3780i_io %x mwave_uart_irq %x mwave_uart_io %x\n",
drivers/char/mwave/smapi.c:		mwave_3780i_irq, mwave_3780i_io, mwave_uart_irq, mwave_uart_io);
drivers/char/mwave/smapi.c:	if (mwave_3780i_io) {
drivers/char/mwave/smapi.c:			if (mwave_3780i_io == ausDspBases[i])
drivers/char/mwave/smapi.c:			PRINTK_ERROR(KERN_ERR_MWAVE "smapi::smapi_set_DSP_cfg: Error: Invalid mwave_3780i_io address %x. Aborting.\n", mwave_3780i_io);
drivers/char/mwave/smapi.c:	if (mwave_3780i_irq) {
drivers/char/mwave/smapi.c:			if (mwave_3780i_irq == ausDspIrqs[i])
drivers/char/mwave/smapi.c:			PRINTK_ERROR(KERN_ERR_MWAVE "smapi::smapi_set_DSP_cfg: Error: Invalid mwave_3780i_irq %x. Aborting.\n", mwave_3780i_irq);
drivers/char/mwave/smapi.c:	if (mwave_uart_io) {
drivers/char/mwave/smapi.c:			if (mwave_uart_io == ausUartBases[i])
drivers/char/mwave/smapi.c:			PRINTK_ERROR(KERN_ERR_MWAVE "smapi::smapi_set_DSP_cfg: Error: Invalid mwave_uart_io address %x. Aborting.\n", mwave_uart_io);
drivers/char/mwave/smapi.c:	if (mwave_uart_irq) {
drivers/char/mwave/smapi.c:			if (mwave_uart_irq == ausUartIrqs[i])
drivers/char/mwave/smapi.c:			PRINTK_ERROR(KERN_ERR_MWAVE "smapi::smapi_set_DSP_cfg: Error: Invalid mwave_uart_irq %x. Aborting.\n", mwave_uart_irq);
drivers/char/mwave/smapi.c:	if (mwave_uart_irq || mwave_uart_io) {
drivers/char/mwave/smapi.c:				if ((usSI & 0xFF) == mwave_uart_irq) {
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: Serial port A irq %x conflicts with mwave_uart_irq %x\n", usSI & 0xFF, mwave_uart_irq);
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: Serial port A irq %x conflicts with mwave_uart_irq %x\n", usSI & 0xFF, mwave_uart_irq);
drivers/char/mwave/smapi.c:							"smapi::smapi_set_DSP_cfg: Serial port A base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI >> 8], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:							"smapi::smapi_set_DSP_cfg: Serial port A base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI >> 8], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:				if ((usSI & 0xFF) == mwave_uart_irq) {
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: Serial port B irq %x conflicts with mwave_uart_irq %x\n", usSI & 0xFF, mwave_uart_irq);
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: Serial port B irq %x conflicts with mwave_uart_irq %x\n", usSI & 0xFF, mwave_uart_irq);
drivers/char/mwave/smapi.c:							"smapi::smapi_set_DSP_cfg: Serial port B base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI >> 8], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:							"smapi::smapi_set_DSP_cfg: Serial port B base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI >> 8], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:			if ((usCX & 0xff) == mwave_uart_irq) {
drivers/char/mwave/smapi.c:					"smapi::smapi_set_DSP_cfg: IR port irq %x conflicts with mwave_uart_irq %x\n", usCX & 0xff, mwave_uart_irq);
drivers/char/mwave/smapi.c:					"smapi::smapi_set_DSP_cfg: IR port irq %x conflicts with mwave_uart_irq %x\n", usCX & 0xff, mwave_uart_irq);
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: IR port base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI & 0xff], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:						"smapi::smapi_set_DSP_cfg: IR port base I/O address %x conflicts with mwave uart I/O %x\n", ausUartBases[usSI & 0xff], ausUartBases[uartio_index]);
drivers/char/mwave/smapi.c:	if (mwave_3780i_io) {
drivers/char/mwave/smapi.c:	if (mwave_3780i_irq) {
drivers/char/mwave/smapi.c:		usSI = (usSI & 0xff00) | mwave_3780i_irq;
drivers/char/mwave/smapi.c:	if (mwave_uart_io) {
drivers/char/mwave/smapi.c:	if (mwave_uart_irq) {
drivers/char/mwave/smapi.c:		usSI = (usSI & 0xff00) | mwave_uart_irq;
drivers/char/mwave/mwavepub.h:* mwavepub.h -- PUBLIC declarations for the mwave driver
drivers/char/mwave/mwavepub.h:	char mwave_os_name[16];
drivers/video/sis/sis_main.c:	  "possible. If you see 'small waves' on the LCD, try setting this to 4, 32 or 24\n"
drivers/video/metronomefb.c:/* the waveform structure that is coming from userspace firmware */
drivers/video/metronomefb.c:struct waveform_hdr {
drivers/video/metronomefb.c:/* here we decode the incoming waveform file and populate metromem */
drivers/video/metronomefb.c:static int __devinit load_waveform(u8 *mem, size_t size, int m, int t,
drivers/video/metronomefb.c:	struct waveform_hdr *wfm_hdr;
drivers/video/metronomefb.c:	wfm_hdr = (struct waveform_hdr *) mem;
drivers/video/metronomefb.c:	the waveform. presumably selecting the right one for the
drivers/video/metronomefb.c:	/* check waveform mode table address checksum */
drivers/video/metronomefb.c:	/* check waveform temperature table address checksum */
drivers/video/metronomefb.c:	/* here we do the real work of putting the waveform into the
drivers/video/metronomefb.c:	metromem buffer. this does runlength decoding of the waveform */
drivers/video/metronomefb.c:		dev_err(dev, "Error: bad waveform data cksum"
drivers/video/metronomefb.c:	contains the display controller commands, waveform,
drivers/video/metronomefb.c:	/* load the waveform in. assume mode 3, temp 31 for now
drivers/video/metronomefb.c:		a) request the waveform file from userspace
drivers/video/metronomefb.c:		b) process waveform and decode into metromem */
drivers/video/metronomefb.c:		dev_err(&dev->dev, "Failed to get waveform\n");
drivers/video/metronomefb.c:	retval = load_waveform((u8 *) fw_entry->data, fw_entry->size, 3, 31,
drivers/video/metronomefb.c:		dev_err(&dev->dev, "Failed processing waveform\n");
drivers/video/metronomefb.c:MODULE_PARM_DESC(user_wfm_size, "Set custom waveform size");
drivers/video/broadsheetfb.c:/* functions for waveform manipulation */
drivers/video/broadsheetfb.c:static int broadsheet_store_waveform_to_spiflash(struct broadsheetfb_par *par,
drivers/video/broadsheetfb.c:static ssize_t broadsheet_loadstore_waveform(struct device *dev,
drivers/video/broadsheetfb.c:		dev_err(dev, "Failed to get broadsheet waveform\n");
drivers/video/broadsheetfb.c:	/* try to enforce reasonable min max on waveform */
drivers/video/broadsheetfb.c:		dev_err(dev, "Invalid waveform\n");
drivers/video/broadsheetfb.c:	err = broadsheet_store_waveform_to_spiflash(par, fw_entry->data,
drivers/video/broadsheetfb.c:		dev_err(dev, "Failed to store broadsheet waveform\n");
drivers/video/broadsheetfb.c:	dev_info(dev, "Stored broadsheet waveform, size %zd\n", fw_entry->size);
drivers/video/broadsheetfb.c:static DEVICE_ATTR(loadstore_waveform, S_IWUSR, NULL,
drivers/video/broadsheetfb.c:			broadsheet_loadstore_waveform);
drivers/video/broadsheetfb.c:	/* setup waveform */
drivers/video/broadsheetfb.c:	retval = device_create_file(&dev->dev, &dev_attr_loadstore_waveform);
drivers/video/broadsheetfb.c:		device_remove_file(info->dev, &dev_attr_loadstore_waveform);
drivers/video/backlight/pwm_bl.c: * 1) pin configuration so PWM waveforms can output
drivers/video/samsung/s3cfb.c:	if(machine_is_wave()) {
drivers/video/samsung/s3cfb_lg4573.c:#include <mach/gpio-wave.h>
drivers/hid/usbhid/hid-pidff.c:			switch (effect->u.periodic.waveform) {
drivers/hid/usbhid/hid-pidff.c:				hid_err(pidff->hid, "invalid waveform\n");
drivers/media/rc/keymaps/Makefile:			rc-azurewave-ad-tu700.o \
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:static struct rc_map_table azurewave_ad_tu700[] = {
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:static struct rc_map_list azurewave_ad_tu700_map = {
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:		.scan    = azurewave_ad_tu700,
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:		.size    = ARRAY_SIZE(azurewave_ad_tu700),
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:static int __init init_rc_map_azurewave_ad_tu700(void)
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:	return rc_map_register(&azurewave_ad_tu700_map);
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:static void __exit exit_rc_map_azurewave_ad_tu700(void)
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:	rc_map_unregister(&azurewave_ad_tu700_map);
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:module_init(init_rc_map_azurewave_ad_tu700)
drivers/media/rc/keymaps/rc-azurewave-ad-tu700.c:module_exit(exit_rc_map_azurewave_ad_tu700)
drivers/media/dvb/frontends/nxt200x.c:		.name = "Nextwave NXT200X VSB/QAM frontend",
drivers/media/dvb/dvb-usb/Kconfig:	tristate "Azurewave DVB-S/S2 USB2.0 AZ6027 support"
drivers/media/dvb/dvb-usb/az6027.c: * Copyright (C) 2009 Adams.Xu <adams.xu@azwave.com.cn>
drivers/media/dvb/dvb-usb/az6027.c:MODULE_AUTHOR("Adams Xu <Adams.xu@azwave.com.cn>");
drivers/media/dvb/ttpci/budget-patch.c:**      wave on GPIO3, changing when a field (TS_HEIGHT/2 "lines" of
drivers/clocksource/tcb_clksrc.c:	/* channel 0:  waveform mode, input mclk/8, clock TIOA0 on overflow */
drivers/clocksource/tcb_clksrc.c:	/* channel 1:  waveform mode, input TIOA0 */
drivers/ssb/sprom.c: * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/ssb/pcihost_wrapper.c: * Copyright (c) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/ssb/scan.c: * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/ssb/pci.c: * Copyright (C) 2005 Andreas Jaggi <andreas.jaggi@waterwave.ch>
drivers/staging/comedi/Kconfig:	tristate "Fake waveform generator support"
drivers/staging/comedi/Kconfig:	  Enable support for the fake waveform generator.
drivers/staging/comedi/Kconfig:	  generate sample waveforms on systems that don't have data acquisition
drivers/staging/comedi/drivers/das1800.c:The waveform analog output on the 'ao' cards is not supported.
drivers/staging/comedi/drivers/das1800.c:	int ao_ability;		/* 0 == no analog out, 1 == basic analog out, 2 == waveform analog out */
drivers/staging/comedi/drivers/amplc_pci224.c:/* (r/w) Wraparound mode enable (to play back stored waveform). */
drivers/staging/comedi/drivers/comedi_test.c:    Generates fake waveform signals that can be read through
drivers/staging/comedi/drivers/comedi_test.c:    it just generates deterministic waveforms.
drivers/staging/comedi/drivers/comedi_test.c:Description: generates fake waveforms
drivers/staging/comedi/drivers/comedi_test.c:generate sample waveforms on systems that don't have data acquisition
drivers/staging/comedi/drivers/comedi_test.c:  [0] - Amplitude in microvolts for fake waveforms (default 1 volt)
drivers/staging/comedi/drivers/comedi_test.c:  [1] - Period in microseconds for fake waveforms (default 0.1 sec)
drivers/staging/comedi/drivers/comedi_test.c:Generates a sawtooth wave on channel 0, square wave on channel 1, additional
drivers/staging/comedi/drivers/comedi_test.c:waveforms could be added to other channels (currently they return flatline
drivers/staging/comedi/drivers/comedi_test.c:struct waveform_board {
drivers/staging/comedi/drivers/comedi_test.c:static const struct waveform_board waveform_boards[] = {
drivers/staging/comedi/drivers/comedi_test.c:#define thisboard ((const struct waveform_board *)dev->board_ptr)
drivers/staging/comedi/drivers/comedi_test.c:struct waveform_private {
drivers/staging/comedi/drivers/comedi_test.c:	unsigned int uvolt_amplitude;	/* waveform amplitude in microvolts */
drivers/staging/comedi/drivers/comedi_test.c:	unsigned long usec_period;	/* waveform period in microseconds */
drivers/staging/comedi/drivers/comedi_test.c:	unsigned long usec_current;	/* current time (modulo waveform period) */
drivers/staging/comedi/drivers/comedi_test.c:#define devpriv ((struct waveform_private *)dev->private)
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_attach(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_detach(struct comedi_device *dev);
drivers/staging/comedi/drivers/comedi_test.c:static struct comedi_driver driver_waveform = {
drivers/staging/comedi/drivers/comedi_test.c:	.attach = waveform_attach,
drivers/staging/comedi/drivers/comedi_test.c:	.detach = waveform_detach,
drivers/staging/comedi/drivers/comedi_test.c:	.board_name = &waveform_boards[0].name,
drivers/staging/comedi/drivers/comedi_test.c:	.offset = sizeof(struct waveform_board),
drivers/staging/comedi/drivers/comedi_test.c:	.num_names = ARRAY_SIZE(waveform_boards),
drivers/staging/comedi/drivers/comedi_test.c:static int __init driver_waveform_init_module(void)
drivers/staging/comedi/drivers/comedi_test.c:	return comedi_driver_register(&driver_waveform);
drivers/staging/comedi/drivers/comedi_test.c:static void __exit driver_waveform_cleanup_module(void)
drivers/staging/comedi/drivers/comedi_test.c:	comedi_driver_unregister(&driver_waveform);
drivers/staging/comedi/drivers/comedi_test.c:module_init(driver_waveform_init_module);
drivers/staging/comedi/drivers/comedi_test.c:module_exit(driver_waveform_cleanup_module);
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cmdtest(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cmd(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cancel(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_insn_read(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ao_insn_write(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static short fake_squarewave(struct comedi_device *dev, unsigned int range,
drivers/staging/comedi/drivers/comedi_test.c:static short fake_waveform(struct comedi_device *dev, unsigned int channel,
drivers/staging/comedi/drivers/comedi_test.c:static const struct comedi_lrange waveform_ai_ranges = {
drivers/staging/comedi/drivers/comedi_test.c:static void waveform_ai_interrupt(unsigned long arg)
drivers/staging/comedi/drivers/comedi_test.c:					    fake_waveform(dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_attach(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:	if (alloc_private(dev, sizeof(struct waveform_private)) < 0)
drivers/staging/comedi/drivers/comedi_test.c:	s->range_table = &waveform_ai_ranges;
drivers/staging/comedi/drivers/comedi_test.c:	s->insn_read = waveform_ai_insn_read;
drivers/staging/comedi/drivers/comedi_test.c:	s->do_cmd = waveform_ai_cmd;
drivers/staging/comedi/drivers/comedi_test.c:	s->do_cmdtest = waveform_ai_cmdtest;
drivers/staging/comedi/drivers/comedi_test.c:	s->cancel = waveform_ai_cancel;
drivers/staging/comedi/drivers/comedi_test.c:	s->range_table = &waveform_ai_ranges;
drivers/staging/comedi/drivers/comedi_test.c:	s->insn_write = waveform_ao_insn_write;
drivers/staging/comedi/drivers/comedi_test.c:	devpriv->timer.function = waveform_ai_interrupt;
drivers/staging/comedi/drivers/comedi_test.c:	       "%i microvolt, %li microsecond waveform attached\n", dev->minor,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_detach(struct comedi_device *dev)
drivers/staging/comedi/drivers/comedi_test.c:		waveform_ai_cancel(dev, dev->read_subdev);
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cmdtest(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cmd(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_cancel(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static short fake_squarewave(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:/* generates a different waveform depending on what channel is read */
drivers/staging/comedi/drivers/comedi_test.c:static short fake_waveform(struct comedi_device *dev, unsigned int channel,
drivers/staging/comedi/drivers/comedi_test.c:		return fake_squarewave(dev, range, current_time);
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ai_insn_read(struct comedi_device *dev,
drivers/staging/comedi/drivers/comedi_test.c:static int waveform_ao_insn_write(struct comedi_device *dev,
drivers/staging/comedi/drivers/usbduxfast.c: * size of the waveform descriptor
drivers/staging/comedi/drivers/addi-data/APCI1710_82x54.c:|                                                    3: Square wave mode     |
drivers/staging/comedi/comedi.h:		I8254_MODE3 = (3 << 1),	/* Square wave mode */
drivers/staging/cxt1e1/comet_tables.h: * The 75 Ohm transmit waveform is not supported on PMCC4.
drivers/staging/cxt1e1/comet.c:#define COMET_NUM_SAMPLES   24  /* Number of entries in the waveform table */
drivers/staging/cxt1e1/comet.c:            lbo = CFG_LBO_LH0;  /* default T1 waveform table */
drivers/staging/cxt1e1/comet.c:            lbo = CFG_LBO_E120;     /* default E1 waveform table */
drivers/staging/cxt1e1/comet.c:        tix = lbo_tbl_lkup (isT1mode, CFG_LBO_LH0);     /* default T1 waveform
drivers/staging/cxt1e1/comet.c:        tix = lbo_tbl_lkup (isT1mode, CFG_LBO_E120);    /* default E1 waveform
drivers/staging/cxt1e1/comet.c:                                                                         * waveform table */
drivers/staging/cxt1e1/comet.c:    pci_write_32 ((u_int32_t *) &comet->xlpg_pwave_addr, WaveformAddr);
drivers/staging/cxt1e1/comet.c:    pci_write_32 ((u_int32_t *) &comet->xlpg_pwave_data, 0x7F & data);
drivers/staging/cxt1e1/comet.h:    VINT32 xlpg_pwave_addr;  /* F2  XLPG Pulse Waveform Storage Write Addr */
drivers/staging/cxt1e1/comet.h:    VINT32 xlpg_pwave_data;  /* F3  XLPG Pulse Waveform Storage Data */
drivers/staging/cxt1e1/comet_tables.c: * comet_tables.c - waveform tables for the PM4351 'COMET'
drivers/staging/cxt1e1/comet_tables.c: * Note that 75 Ohm transmit waveform is not supported on PMCC4.
drivers/staging/xgifb/XGI_main_26.c:		"possible. If you see 'small waves' on the LCD, try setting this to 4, 32 or 24\n"
drivers/staging/lirc/lirc_serial.c: *     not needed. Measurement shows very stable waveform, even where
drivers/staging/iio/meter/ade7753.c:				    present in the waveform register */
drivers/staging/iio/meter/ade7759.c:				    present in the waveform register */
drivers/staging/iio/meter/meter.h:/* on the rising and falling edge of the the voltage waveform */
drivers/staging/iio/meter/meter.h:/* waveform sample from Channel 1 has exceeded the IPKLVL value */
drivers/staging/iio/meter/meter.h:/* waveform sample from Channel 2 has exceeded the VPKLVL value */
drivers/staging/iio/meter/ade7758_ring.c:static int ade7758_write_waveform_type(struct device *dev, unsigned type)
drivers/staging/iio/meter/ade7758_ring.c:	ade7758_write_waveform_type(&indio_dev->dev,
drivers/staging/iio/meter/ade7754.c:				     present in the waveform register */
drivers/staging/iio/meter/ade7758_core.c:				     present in the waveform register */
drivers/staging/iio/light/tsl2563.c: * of the intensities in infrared and visible wavelengths). lux_table below
drivers/staging/iio/Documentation/sysfs-bus-iio-dds:What:		/sys/bus/iio/devices/.../ddsX_outY_wavetype
drivers/staging/iio/Documentation/sysfs-bus-iio-dds:		Specifies the output waveform.
drivers/staging/iio/Documentation/sysfs-bus-iio-dds:		For a list of available output waveform options read
drivers/staging/iio/Documentation/sysfs-bus-iio-dds:What:		/sys/bus/iio/devices/.../ddsX_outY_wavetype_available
drivers/staging/iio/Documentation/sysfs-bus-iio-dds:		Lists all available output waveform options.
drivers/staging/iio/dds/dds.h: * /sys/bus/iio/devices/.../ddsX_outY_wavetype
drivers/staging/iio/dds/dds.h:	IIO_DEVICE_ATTR(dds##_channel##_out##_output##_wavetype,	\
drivers/staging/iio/dds/dds.h: * /sys/bus/iio/devices/.../ddsX_outY_wavetype_available
drivers/staging/iio/dds/dds.h:	IIO_CONST_ATTR(dds##_channel##_out##_output##_wavetype_available,\
drivers/staging/iio/dds/ad9834.c:static ssize_t ad9834_store_wavetype(struct device *dev,
drivers/staging/iio/dds/ad9834.c:static ssize_t ad9834_show_out0_wavetype_available(struct device *dev,
drivers/staging/iio/dds/ad9834.c:static IIO_DEVICE_ATTR(dds0_out0_wavetype_available, S_IRUGO,
drivers/staging/iio/dds/ad9834.c:		       ad9834_show_out0_wavetype_available, NULL, 0);
drivers/staging/iio/dds/ad9834.c:static ssize_t ad9834_show_out1_wavetype_available(struct device *dev,
drivers/staging/iio/dds/ad9834.c:static IIO_DEVICE_ATTR(dds0_out1_wavetype_available, S_IRUGO,
drivers/staging/iio/dds/ad9834.c:		       ad9834_show_out1_wavetype_available, NULL, 0);
drivers/staging/iio/dds/ad9834.c:static IIO_DEV_ATTR_OUT_WAVETYPE(0, 0, ad9834_store_wavetype, 0);
drivers/staging/iio/dds/ad9834.c:static IIO_DEV_ATTR_OUT_WAVETYPE(0, 1, ad9834_store_wavetype, 1);
drivers/staging/iio/dds/ad9834.c:	&iio_dev_attr_dds0_out0_wavetype.dev_attr.attr,
drivers/staging/iio/dds/ad9834.c:	&iio_dev_attr_dds0_out1_wavetype.dev_attr.attr,
drivers/staging/iio/dds/ad9834.c:	&iio_dev_attr_dds0_out0_wavetype_available.dev_attr.attr,
drivers/staging/iio/dds/ad9834.c:	&iio_dev_attr_dds0_out1_wavetype_available.dev_attr.attr,
drivers/staging/iio/dds/ad9834.c:		(attr == &iio_dev_attr_dds0_out1_wavetype.dev_attr.attr) ||
drivers/staging/iio/dds/ad9834.c:		&iio_dev_attr_dds0_out1_wavetype_available.dev_attr.attr) ||
drivers/staging/usbip/userspace/usb.ids:06c6  Infowave Software, Inc.
drivers/staging/usbip/userspace/usb.ids:0e1b  Crewave
drivers/staging/usbip/userspace/usb.ids:12ef  Tapwave, Inc.
drivers/staging/usbip/userspace/usb.ids:	0100  Tapwave Handheld [Tapwave Zodiac]
drivers/staging/wlags49_h2/wl_profile.c:	/* Get the wavelan specific info for this device */
drivers/staging/wlags49_h2/wl_profile.c:		DBG_ERROR(DbgInfo, "Config file buffer and/or wavelan buffer ptr NULL\n");
drivers/staging/wlags49_h2/wl_profile.c:		lp->MicrowaveRobustness = parse_yes_no(value);
drivers/staging/wlags49_h2/mdd.h: X1( CFG_CNF_MICRO_WAVE,			micro_wave			 ) /*MicroWave (Robustness)									*/
drivers/staging/wlags49_h2/wl_internal.h:	hcf_8                       MicrowaveRobustness;// 0 - 1 (0)
drivers/staging/wlags49_h2/man/wlags49.4:thresholds, microwave robustness, RTS/CTS thresholds, by APs. The associated
drivers/staging/wlags49_h2/man/wlags49.4:Enable or disable Microwave Oven Robustness.
drivers/staging/wlags49_h2/wl_main.c:MODULE_PARM_DESC(PARM_MICROWAVE_ROBUSTNESS,     "Microwave Oven Robustness Enabled (<string> N or Y) [N]");
drivers/staging/wlags49_h2/wl_main.c:		lp->MicrowaveRobustness = 1;
drivers/staging/wlags49_h2/wl_main.c:		lp->MicrowaveRobustness = 0;
drivers/staging/wlags49_h2/wl_main.c:	/* Microwave Robustness */
drivers/staging/wlags49_h2/wl_main.c:	lp->ltvRecord.u.u16[0]  = CNV_INT_TO_LITTLE( lp->MicrowaveRobustness );
drivers/staging/wlags49_h2/wl_main.c:   	    len += sprintf(buf+len,"MicrowaveRobustness:  0x%04X\n", lp->MicrowaveRobustness );// 0 - 1 (0)
drivers/leds/leds-bd2802.c:	int				wave_pattern;
drivers/leds/leds-bd2802.c:	bd2802_write_byte(led->client, reg, led->wave_pattern);
drivers/leds/leds-bd2802.c:BD2802_CONTROL_ATTR(wave_pattern, "wave_pattern");
drivers/leds/leds-bd2802.c:	&bd2802_wave_pattern_attr,
drivers/leds/leds-bd2802.c:	led->wave_pattern = BD2802_PATTERN_HALF;
drivers/misc/Kconfig:	  on LCD displays, motor control, and waveform generation.
drivers/misc/samsung_modemctl/Makefile:obj-$(CONFIG_MACH_WAVE)	+= wave/
drivers/misc/ioc4.c:	/* Set up square wave */
drivers/misc/ioc4.c:	/* Check square wave period averaged over some number of cycles */
drivers/misc/ioc4.c:	 *    the square wave cycles.
drivers/misc/ioc4.c:	 * 2. Divide by number of square wave cycles to get the period
drivers/misc/ioc4.c:	 *    of a square wave cycle.
drivers/misc/ioc4.c:	 *    by which the IOC4 generates the square wave, to get the
drivers/rtc/rtc-m41t80.c:#define M41T80_FEATURE_SQ	(1 << 2)	/* Squarewave feature */
drivers/rtc/rtc-ds1286.c:		   "square_wave\t: %s\n",
drivers/rtc/rtc-cmos.c:			// "square_wave\t: %s\n"
drivers/rtc/rtc-ds1307.c:		/* Using IRQ?  Disable the square wave and both alarms.
firmware/WHENCE:Driver: wavefront - ISA WaveFront sound card
include/asm-generic/rtc.h:#define RTC_SQWE 0x08		/* enable square-wave output */
include/scsi/fc/fc_els.h:	ELS_RNIDA_MF_WDM =	1UL << 24,	/* wavelength division mux */
include/sound/trident.h:struct snd_4dwave {
include/sound/trident.h:	struct snd_4dwave synth;	/* synth specific variables */
include/sound/trident.h:	unsigned int musicvol_wavevol;
include/sound/trident.h:		       int max_wavetable_size,
include/sound/emu10k1_synth.h:	int max_voices;		/* maximum number of voices for wavetable */
include/sound/emux_synth.h: * emuX wavetable
include/sound/asequencer.h:#define SNDRV_SEQ_PORT_TYPE_SYNTH	(1<<10)	/* Synth device (no MIDI compatible - direct wavetable) */
include/sound/opl3.h:	unsigned char wave_select;
include/sound/snd_wavefront.h:#include "wavefront.h"  /* generic OSS/ALSA/user-level wavefront header */
include/sound/snd_wavefront.h:struct _snd_wavefront_midi;
include/sound/snd_wavefront.h:struct _snd_wavefront_card;
include/sound/snd_wavefront.h:struct _snd_wavefront;
include/sound/snd_wavefront.h:typedef struct _snd_wavefront_midi snd_wavefront_midi_t;
include/sound/snd_wavefront.h:typedef struct _snd_wavefront_card snd_wavefront_card_t;
include/sound/snd_wavefront.h:typedef struct _snd_wavefront snd_wavefront_t;
include/sound/snd_wavefront.h:typedef enum { internal_mpu = 0, external_mpu = 1 } snd_wavefront_mpu_id;
include/sound/snd_wavefront.h:struct _snd_wavefront_midi {
include/sound/snd_wavefront.h:        snd_wavefront_mpu_id     output_mpu;  /* most-recently-used */
include/sound/snd_wavefront.h:        snd_wavefront_mpu_id     input_mpu;   /* most-recently-used */
include/sound/snd_wavefront.h:extern struct snd_rawmidi_ops snd_wavefront_midi_output;
include/sound/snd_wavefront.h:extern struct snd_rawmidi_ops snd_wavefront_midi_input;
include/sound/snd_wavefront.h:extern void   snd_wavefront_midi_enable_virtual (snd_wavefront_card_t *);
include/sound/snd_wavefront.h:extern void   snd_wavefront_midi_disable_virtual (snd_wavefront_card_t *);
include/sound/snd_wavefront.h:extern void   snd_wavefront_midi_interrupt (snd_wavefront_card_t *);
include/sound/snd_wavefront.h:extern int    snd_wavefront_midi_start (snd_wavefront_card_t *);
include/sound/snd_wavefront.h:struct _snd_wavefront {
include/sound/snd_wavefront.h:	snd_wavefront_midi_t midi;         /* ICS2115 MIDI interface */
include/sound/snd_wavefront.h:struct _snd_wavefront_card {
include/sound/snd_wavefront.h:	snd_wavefront_t wavefront;
include/sound/snd_wavefront.h:extern void snd_wavefront_internal_interrupt (snd_wavefront_card_t *card);
include/sound/snd_wavefront.h:extern int  snd_wavefront_detect_irq (snd_wavefront_t *dev) ;
include/sound/snd_wavefront.h:extern int  snd_wavefront_check_irq (snd_wavefront_t *dev, int irq);
include/sound/snd_wavefront.h:extern int  snd_wavefront_restart (snd_wavefront_t *dev);
include/sound/snd_wavefront.h:extern int  snd_wavefront_start (snd_wavefront_t *dev);
include/sound/snd_wavefront.h:extern int  snd_wavefront_detect (snd_wavefront_card_t *card);
include/sound/snd_wavefront.h:extern int  snd_wavefront_config_midi (snd_wavefront_t *dev) ;
include/sound/snd_wavefront.h:extern int  snd_wavefront_cmd (snd_wavefront_t *, int, unsigned char *,
include/sound/snd_wavefront.h:extern int snd_wavefront_synth_ioctl   (struct snd_hwdep *, 
include/sound/snd_wavefront.h:extern int  snd_wavefront_synth_open    (struct snd_hwdep *, struct file *);
include/sound/snd_wavefront.h:extern int  snd_wavefront_synth_release (struct snd_hwdep *, struct file *);
include/sound/snd_wavefront.h:extern int  snd_wavefront_fx_start  (snd_wavefront_t *);
include/sound/snd_wavefront.h:extern int  snd_wavefront_fx_detect (snd_wavefront_t *);
include/sound/snd_wavefront.h:extern int  snd_wavefront_fx_ioctl  (struct snd_hwdep *, 
include/sound/snd_wavefront.h:extern int snd_wavefront_fx_open    (struct snd_hwdep *, struct file *);
include/sound/snd_wavefront.h:extern int snd_wavefront_fx_release (struct snd_hwdep *, struct file *);
include/sound/asound_fm.h:	unsigned char waveform;		/* 3 bits: waveform shape */
include/sound/emu8000.h: * the number in use for wave voices.
include/sound/emu8000.h:	struct snd_pcm *pcm; /* pcm on emu8000 wavetable */
include/sound/cs4231-regs.h:#define CS4236_LEFT_WAVE	0x0c	/* left wavetable serial port volume */
include/sound/cs4231-regs.h:#define CS4236_RIGHT_WAVE	0x1c	/* right wavetable serial port volume */
include/sound/asound.h:	SNDRV_HWDEP_IFACE_EMUX_WAVETABLE, /* EmuX wavetable */	
include/sound/cs46xx_dsp_scb_types.h:	   On wavetable/3D voices: the strmBufPtr will use all 32 bits to allow for
include/sound/cs46xx_dsp_scb_types.h:	   On wavetable/3D voices: this 32-bit word specifies the integer.fractional 
include/sound/cs46xx_dsp_scb_types.h:	   These two 32-bit words are redefined for wavetable & 3-D voices.    
include/sound/wavefront.h:     it is necessary to pack the "wavefront_alias" structure to a size
include/sound/wavefront.h:     All other wavefront_* types end up aligned to 32 bit values and
include/sound/wavefront.h:/* These are very useful/important. the original wavefront interface
include/sound/wavefront.h:typedef struct wf_envelope wavefront_envelope;
include/sound/wavefront.h:    u8 wave_restart:1; /* for LFO2 only */
include/sound/wavefront.h:typedef struct wf_lfo wavefront_lfo;
include/sound/wavefront.h:typedef struct wf_patch wavefront_patch;
include/sound/wavefront.h:typedef struct wf_layer wavefront_layer;
include/sound/wavefront.h:typedef struct wf_program wavefront_program;
include/sound/wavefront.h:typedef struct wf_sample_offset wavefront_sample_offset;          
include/sound/wavefront.h:  this without using some struct other than wavefront_sample as the
include/sound/wavefront.h:  wavefront_sample:
include/sound/wavefront.h:} wavefront_sample;
include/sound/wavefront.h:} wavefront_multisample;
include/sound/wavefront.h:} __attribute__((packed)) wavefront_alias;
include/sound/wavefront.h:} wavefront_drum;
include/sound/wavefront.h:} wavefront_drumkit;
include/sound/wavefront.h:} wavefront_channel_programs;
include/sound/wavefront.h:    wavefront_sample s;
include/sound/wavefront.h:    wavefront_multisample ms;
include/sound/wavefront.h:    wavefront_alias a;
include/sound/wavefront.h:    wavefront_program pr;
include/sound/wavefront.h:    wavefront_patch p;
include/sound/wavefront.h:    wavefront_drum d;
include/sound/wavefront.h:} wavefront_any;
include/sound/wavefront.h:   might work for other wave-table based patch loading situations.
include/sound/wavefront.h:    wavefront_any __user *hdrptr;      /* user-space ptr to hdr bytes */
include/sound/wavefront.h:    wavefront_any hdr;          /* kernel-space copy of hdr bytes */         
include/sound/wavefront.h:} wavefront_patch_info;
include/sound/wavefront.h:#define WF_MAX_READ sizeof(wavefront_multisample)
include/sound/wavefront.h:#define WF_MAX_WRITE sizeof(wavefront_multisample)
include/sound/wavefront.h:typedef struct wavefront_control {
include/sound/wavefront.h:} wavefront_control;
include/sound/wavefront.h:} wavefront_fx_info;
include/sound/gus.h:	unsigned int interrupt_stat_wave;
include/sound/gus.h:	void (*handler_wave) (struct snd_gus_card * gus, struct snd_gus_voice * voice);
include/sound/gus.h:	 interwave:1,			/* hey - we have InterWave card */
include/sound/gus.h:	unsigned short twave;
include/sound/sfnt_info.h:/* wave table envelope & effect parameters to control EMU8000 */
include/sound/sfnt_info.h:/* wave table parameters: 92 bytes */
include/sound/sfnt_info.h: * sample wave information
include/sound/sfnt_info.h:/* wave table sample header: 32 bytes */
include/sound/sfnt_info.h:#define SNDRV_SFNT_SAMPLE_8BITS		1	/* wave data is 8bits */
include/sound/sfnt_info.h:#define SNDRV_SFNT_SAMPLE_UNSIGNED	2	/* wave data is unsigned */
include/sound/emu8000_reg.h: *  Based on awe_wave.c by Takashi Iwai
include/media/saa7146.h:/* some events and command modifiers for rps1 squarewave generator */
include/media/rc-map.h:#define RC_MAP_AZUREWAVE_AD_TU700        "rc-azurewave-ad-tu700"
include/linux/atmel_tc.h: * one of the other two timers that's being run in waveform mode.
include/linux/atmel_tc.h: * The timers can be chained in various ways, and operated in "waveform"
include/linux/atmel_tc.h:#define     ATMEL_TC_WAVESEL	(3 << 13)	/* waveform type */
include/linux/mc146818rtc.h:  /* Periodic intr. / Square wave rate select. 0=none, 1=32.8kHz,... 15=2Hz */
include/linux/mc146818rtc.h:# define RTC_SQWE 0x08		/* enable square-wave output */
include/linux/soundcard.h:#define WAVE_16_BITS	0x01	/* bit 0 = 8 or 16 bit wave data. */
include/linux/soundcard.h:		int len;	/* Size of the wave data in bytes */
include/linux/soundcard.h:		char data[1];	/* The waveform data starts here */
include/linux/soundcard.h: *	For wave table use struct patch_info. Initialize the key field
include/linux/mlx4/device.h:	int			wavelength[MLX4_MAX_PORTS + 1];
include/linux/miscdevice.h:#define MWAVE_MINOR		219	/* ACP/Mwave Modem */
include/linux/leds-bd2802.h:#define RGB_TIME(slopedown, slopeup, waveform) \
include/linux/leds-bd2802.h:	((slopedown) << 6 | (slopeup) << 4 | (waveform))
include/linux/input.h: * @waveform: kind of the effect (wave)
include/linux/input.h: * @period: period of the wave (ms)
include/linux/input.h: * @offset: mean value of the wave (roughly)
include/linux/input.h: * Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,
include/linux/input.h:	__u16 waveform;
Makefile:CROSS_COMPILE	?= /home/demo/VidÃ©os/wave_sd/toolchain/bin/arm-linux-gnueabihf-
sound/drivers/opl3/opl3_drums.c:	unsigned char wave_select;
sound/drivers/opl3/opl3_drums.c:	/* Select waveform */
sound/drivers/opl3/opl3_drums.c:	opl3->command(opl3, opl3_reg, data->wave_select);
sound/drivers/opl3/opl3_midi.c:		/* Select waveform */
sound/drivers/opl3/opl3_midi.c:		reg_val = fm->op[i].wave_select;
sound/drivers/opl3/opl3_synth.c:		patch->inst.op[i].wave_select = data[WAVE_SELECT + i];
sound/drivers/opl3/opl3_synth.c:			patch->inst.op[i+2].wave_select =
sound/drivers/opl3/opl3_synth.c:	/* Select waveform */
sound/drivers/opl3/opl3_synth.c:	reg_val = voice->waveform & OPL3_WAVE_SELECT_MASK;
sound/drivers/opl4/opl4_synth.c:static void snd_opl4_wait_for_wave_headers(struct snd_opl4 *opl4)
sound/drivers/opl4/opl4_synth.c:	snd_opl4_wait_for_wave_headers(opl4);
sound/drivers/opl4/yrw801.c: * Information about the Yamaha YRW801 wavetable ROM chip
sound/drivers/opl4/opl4_seq.c:MODULE_DESCRIPTION("OPL4 wavetable synth driver");
sound/drivers/opl4/opl4_seq.c:MODULE_PARM_DESC(volume_boost, "Additional volume for OPL4 wavetable sounds.");
sound/ppc/beep.c:	short *buf;		/* allocated wave buffer */
sound/firewire/speakers.c:static int firewave_rate_constraint(struct snd_pcm_hw_params *params,
sound/firewire/speakers.c:static int firewave_channels_constraint(struct snd_pcm_hw_params *params,
sound/firewire/speakers.c:static int firewave_constraints(struct snd_pcm_runtime *runtime)
sound/firewire/speakers.c:				  firewave_rate_constraint, NULL,
sound/firewire/speakers.c:				  firewave_channels_constraint, NULL,
sound/firewire/speakers.c:	static const struct device_info griffin_firewave = {
sound/firewire/speakers.c:		.pcm_constraints = firewave_constraints,
sound/firewire/speakers.c:				return &griffin_firewave;
sound/synth/emux/emux_synth.c: *  Contains code based on awe_wave.c by Takashi Iwai
sound/synth/emux/emux_proc.c:	sprintf(name, "wavetableD%d", device);
sound/synth/emux/emux_effect.c: *  Contains code based on awe_wave.c by Takashi Iwai
sound/synth/emux/emux_effect.c:/* copy wavetable registers to voice table */
sound/synth/emux/soundfont.c:	 * If there is wave data then load it.
sound/synth/emux/soundfont.c:	 * load wave data
sound/isa/sb/emu8000_pcm.c: * pcm emulation on emu8000 wavetable
sound/isa/sb/sb16.c:		snd_printdd("pnp SB16: wavetable port=0x%llx\n",
sound/isa/Kconfig:	  will be called snd-interwave.
sound/isa/Kconfig:	  will be called snd-interwave-stb.
sound/isa/Kconfig:	  will be called snd-wavefront.
sound/isa/Makefile:		     sb/ wavefront/ wss/
sound/isa/wavefront/wavefront_synth.c: * An ALSA lowlevel driver for Turtle Beach ICS2115 wavetable synth
sound/isa/wavefront/wavefront_synth.c: * This driver supports the onboard wavetable synthesizer (an ICS2115),
sound/isa/wavefront/wavefront_synth.c:#include <sound/snd_wavefront.h>
sound/isa/wavefront/wavefront_synth.c:				  wavefront.h
sound/isa/wavefront/wavefront_synth.c:#define DEFAULT_OSPATH	"wavefront.os"
sound/isa/wavefront/wavefront_synth.c:static int wavefront_delete_sample (snd_wavefront_t *, int sampnum);
sound/isa/wavefront/wavefront_synth.c:static int wavefront_find_free_sample (snd_wavefront_t *);
sound/isa/wavefront/wavefront_synth.c:struct wavefront_command {
sound/isa/wavefront/wavefront_synth.c:} wavefront_errors[] = {
sound/isa/wavefront/wavefront_synth.c:static struct wavefront_command wavefront_commands[] = {
sound/isa/wavefront/wavefront_synth.c:	   There is a hack in snd_wavefront_cmd() to support this. The actual
sound/isa/wavefront/wavefront_synth.c:wavefront_errorstr (int errnum)
sound/isa/wavefront/wavefront_synth.c:	for (i = 0; wavefront_errors[i].errstr; i++) {
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_errors[i].errno == errnum) {
sound/isa/wavefront/wavefront_synth.c:			return wavefront_errors[i].errstr;
sound/isa/wavefront/wavefront_synth.c:static struct wavefront_command *
sound/isa/wavefront/wavefront_synth.c:wavefront_get_command (int cmd) 
sound/isa/wavefront/wavefront_synth.c:	for (i = 0; wavefront_commands[i].cmd != 0; i++) {
sound/isa/wavefront/wavefront_synth.c:		if (cmd == wavefront_commands[i].cmd) {
sound/isa/wavefront/wavefront_synth.c:			return &wavefront_commands[i];
sound/isa/wavefront/wavefront_synth.c:wavefront_status (snd_wavefront_t *dev) 
sound/isa/wavefront/wavefront_synth.c:wavefront_sleep (int limit)
sound/isa/wavefront/wavefront_synth.c:wavefront_wait (snd_wavefront_t *dev, int mask)
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_status (dev) & mask) {
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_status (dev) & mask) {
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_sleep (HZ/sleep_interval)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_read (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	if (wavefront_wait (dev, STAT_CAN_READ))
sound/isa/wavefront/wavefront_synth.c:wavefront_write (snd_wavefront_t *dev, unsigned char data)
sound/isa/wavefront/wavefront_synth.c:	if (wavefront_wait (dev, STAT_CAN_WRITE)) {
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_cmd (snd_wavefront_t *dev, 
sound/isa/wavefront/wavefront_synth.c:	struct wavefront_command *wfcmd;
sound/isa/wavefront/wavefront_synth.c:	if ((wfcmd = wavefront_get_command (cmd)) == NULL) {
sound/isa/wavefront/wavefront_synth.c:	   wavefront_send_multisample() for the other half of this
sound/isa/wavefront/wavefront_synth.c:	if (wavefront_write (dev, cmd)) { 
sound/isa/wavefront/wavefront_synth.c:			if (wavefront_write (dev, wbuf[i])) {
sound/isa/wavefront/wavefront_synth.c:			if ((c = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:				if ((c = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:							      wavefront_errorstr (c),
sound/isa/wavefront/wavefront_synth.c:		if ((ack = wavefront_read (dev)) == 0) {
sound/isa/wavefront/wavefront_synth.c:					if ((err = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:					wavefront_errorstr (err));
sound/isa/wavefront/wavefront_synth.c:wavefront_delete_sample (snd_wavefront_t *dev, int sample_num)
sound/isa/wavefront/wavefront_synth.c:	if ((x = snd_wavefront_cmd (dev, WFC_DELETE_SAMPLE, NULL, wbuf)) == 0) {
sound/isa/wavefront/wavefront_synth.c:wavefront_get_sample_status (snd_wavefront_t *dev, int assume_rom)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_GET_NSAMPLES, rbuf, wbuf)) {
sound/isa/wavefront/wavefront_synth.c:		if (snd_wavefront_cmd (dev, WFC_IDENTIFY_SAMPLE_TYPE, rbuf, wbuf)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_get_patch_status (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	wavefront_patch *p;
sound/isa/wavefront/wavefront_synth.c:		if ((x = snd_wavefront_cmd (dev, WFC_UPLOAD_PATCH, patchbuf,
sound/isa/wavefront/wavefront_synth.c:			p = (wavefront_patch *) patchbuf;
sound/isa/wavefront/wavefront_synth.c:wavefront_get_program_status (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	wavefront_program prog;
sound/isa/wavefront/wavefront_synth.c:		if ((x = snd_wavefront_cmd (dev, WFC_UPLOAD_PROGRAM, progbuf,
sound/isa/wavefront/wavefront_synth.c:wavefront_send_patch (snd_wavefront_t *dev, wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PATCH, NULL, buf)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_send_program (snd_wavefront_t *dev, wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PROGRAM, NULL, buf)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_freemem (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_REPORT_FREE_MEMORY, rbuf, NULL)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_send_sample (snd_wavefront_t *dev, 
sound/isa/wavefront/wavefront_synth.c:		       wavefront_patch_info *header,
sound/isa/wavefront/wavefront_synth.c:		if ((x = wavefront_find_free_sample (dev)) < 0) {
sound/isa/wavefront/wavefront_synth.c:		wavefront_delete_sample (dev, header->number);
sound/isa/wavefront/wavefront_synth.c:		dev->freemem = wavefront_freemem (dev);
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, 
sound/isa/wavefront/wavefront_synth.c:		if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_BLOCK, NULL, NULL)) {
sound/isa/wavefront/wavefront_synth.c:		if ((dma_ack = wavefront_read (dev)) != WF_DMA_ACK) {
sound/isa/wavefront/wavefront_synth.c:wavefront_send_alias (snd_wavefront_t *dev, wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_SAMPLE_ALIAS, NULL, alias_hdr)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_send_multisample (snd_wavefront_t *dev, wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	   in a wavefront_multisample struct is actually the log2 of the
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_MULTISAMPLE, 
sound/isa/wavefront/wavefront_synth.c:wavefront_fetch_multisample (snd_wavefront_t *dev, 
sound/isa/wavefront/wavefront_synth.c:			     wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_UPLOAD_MULTISAMPLE, log_ns, number)) {
sound/isa/wavefront/wavefront_synth.c:		if ((val = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:		if ((val = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:wavefront_send_drum (snd_wavefront_t *dev, wavefront_patch_info *header)
sound/isa/wavefront/wavefront_synth.c:	wavefront_drum *drum = &header->hdr.d;
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_DOWNLOAD_EDRUM_PROGRAM, NULL, drumbuf)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_find_free_sample (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:wavefront_find_free_patch (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:wavefront_load_patch (snd_wavefront_t *dev, const char __user *addr)
sound/isa/wavefront/wavefront_synth.c:	wavefront_patch_info *header;
sound/isa/wavefront/wavefront_synth.c:	if (copy_from_user (header, addr, sizeof(wavefront_patch_info) -
sound/isa/wavefront/wavefront_synth.c:			    sizeof(wavefront_any))) {
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_sample))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_sample (dev, header, header->dataptr, 0);
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_multisample))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_multisample (dev, header);
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_alias))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_alias (dev, header);
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_drum))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_drum (dev, header);
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_patch))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_patch (dev, header);
sound/isa/wavefront/wavefront_synth.c:				    sizeof (wavefront_program))) {
sound/isa/wavefront/wavefront_synth.c:		err = wavefront_send_program (dev, header);
sound/isa/wavefront/wavefront_synth.c:	wavefront_sample s;
sound/isa/wavefront/wavefront_synth.c:	/* The board doesn't send us an exact copy of a "wavefront_sample"
sound/isa/wavefront/wavefront_synth.c:	memcpy (buf, (unsigned char *) &s, sizeof (wavefront_sample));
sound/isa/wavefront/wavefront_synth.c:wavefront_synth_control (snd_wavefront_card_t *acard, 
sound/isa/wavefront/wavefront_synth.c:			 wavefront_control *wc)
sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &acard->wavefront;
sound/isa/wavefront/wavefront_synth.c:		   cannot be dealt with properly by snd_wavefront_cmd() alone.
sound/isa/wavefront/wavefront_synth.c:		wc->status = wavefront_fetch_multisample
sound/isa/wavefront/wavefront_synth.c:			(dev, (wavefront_patch_info *) wc->rbuf);
sound/isa/wavefront/wavefront_synth.c:	wc->status = snd_wavefront_cmd (dev, wc->cmd, wc->rbuf, wc->wbuf);
sound/isa/wavefront/wavefront_synth.c:			snd_wavefront_midi_disable_virtual (acard);
sound/isa/wavefront/wavefront_synth.c:			snd_wavefront_midi_enable_virtual (acard);
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_synth_open (struct snd_hwdep *hw, struct file *file)
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_synth_release (struct snd_hwdep *hw, struct file *file)
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_synth_ioctl (struct snd_hwdep *hw, struct file *file,
sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev;
sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_card_t *acard;
sound/isa/wavefront/wavefront_synth.c:	wavefront_control *wc;
sound/isa/wavefront/wavefront_synth.c:	dev = &acard->wavefront;
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_load_patch (dev, argp) != 0) {
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_synth_control (acard, wc) < 0)
sound/isa/wavefront/wavefront_synth.c:/*  WaveFront: interface for card-level wavefront module               */
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_internal_interrupt (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &card->wavefront;
sound/isa/wavefront/wavefront_synth.c:	   during firmware loading, and after that wavefront_status()
sound/isa/wavefront/wavefront_synth.c:	   driver. Note also that wavefront_status() continues to
sound/isa/wavefront/wavefront_synth.c:	   wavefront_wait(), the only place where this really
sound/isa/wavefront/wavefront_synth.c:	if ((wavefront_status(dev) & (STAT_INTR_READ|STAT_INTR_WRITE)) == 0) {
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_interrupt_bits (int irq)
sound/isa/wavefront/wavefront_synth.c:wavefront_should_cause_interrupt (snd_wavefront_t *dev, 
sound/isa/wavefront/wavefront_synth.c:wavefront_reset_to_cleanliness (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	bits = snd_wavefront_interrupt_bits (dev->irq);
sound/isa/wavefront/wavefront_synth.c:	wavefront_should_cause_interrupt(dev, 0x80|0x40|0x10|0x1,
sound/isa/wavefront/wavefront_synth.c:	wavefront_should_cause_interrupt(dev, WFC_HARDWARE_VERSION, 
sound/isa/wavefront/wavefront_synth.c:	if (!wavefront_wait (dev, STAT_CAN_READ)) {
sound/isa/wavefront/wavefront_synth.c:	if ((hwv[0] = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:		if ((hwv[0] = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:	if ((hwv[1] = wavefront_read (dev)) == -1) {
sound/isa/wavefront/wavefront_synth.c:wavefront_download_firmware (snd_wavefront_t *dev, char *path)
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_write(dev, WFC_DOWNLOAD_OS))
sound/isa/wavefront/wavefront_synth.c:			if (wavefront_write(dev, *buf))
sound/isa/wavefront/wavefront_synth.c:		if (!wavefront_wait(dev, STAT_CAN_READ)) {
sound/isa/wavefront/wavefront_synth.c:wavefront_do_reset (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	if (wavefront_reset_to_cleanliness (dev)) {
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_download_firmware (dev, ospath)) {
sound/isa/wavefront/wavefront_synth.c:		wavefront_should_cause_interrupt (dev, WFC_NOOP,
sound/isa/wavefront/wavefront_synth.c:		wavefront_should_cause_interrupt (dev, WFC_NOOP,
sound/isa/wavefront/wavefront_synth.c:	if ((dev->freemem = wavefront_freemem (dev)) < 0) {
sound/isa/wavefront/wavefront_synth.c:	if (wavefront_write (dev, 0xf0) ||
sound/isa/wavefront/wavefront_synth.c:	    wavefront_write (dev, 1) ||
sound/isa/wavefront/wavefront_synth.c:	    (wavefront_read (dev) < 0)) {
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_SET_NVOICES, NULL, voices)) {
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_start (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_synth.c:	/* IMPORTANT: assumes that snd_wavefront_detect() and/or
sound/isa/wavefront/wavefront_synth.c:	   wavefront_reset_to_cleanliness() has already been called 
sound/isa/wavefront/wavefront_synth.c:		if (wavefront_do_reset (dev)) {
sound/isa/wavefront/wavefront_synth.c:	dev->has_fx = (snd_wavefront_fx_detect (dev) == 0);
sound/isa/wavefront/wavefront_synth.c:		snd_wavefront_fx_start (dev);
sound/isa/wavefront/wavefront_synth.c:	wavefront_get_sample_status (dev, samples_are_from_rom);
sound/isa/wavefront/wavefront_synth.c:	wavefront_get_program_status (dev);
sound/isa/wavefront/wavefront_synth.c:	wavefront_get_patch_status (dev);
sound/isa/wavefront/wavefront_synth.c:snd_wavefront_detect (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &card->wavefront;
sound/isa/wavefront/wavefront_synth.c:	if (snd_wavefront_cmd (dev, WFC_FIRMWARE_VERSION, rbuf, wbuf) == 0) {
sound/isa/wavefront/wavefront_synth.c:		if (snd_wavefront_cmd (dev, WFC_HARDWARE_VERSION,
sound/isa/wavefront/Makefile:snd-wavefront-objs := wavefront.o wavefront_fx.o wavefront_synth.o wavefront_midi.o
sound/isa/wavefront/Makefile:obj-$(CONFIG_SND_WAVEFRONT) += snd-wavefront.o
sound/isa/wavefront/wavefront_fx.c:#include <sound/snd_wavefront.h>
sound/isa/wavefront/wavefront_fx.c:wavefront_fx_idle (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_fx.c:wavefront_fx_mute (snd_wavefront_t *dev, int onoff)
sound/isa/wavefront/wavefront_fx.c:	if (!wavefront_fx_idle(dev)) {
sound/isa/wavefront/wavefront_fx.c:wavefront_fx_memset (snd_wavefront_t *dev,
sound/isa/wavefront/wavefront_fx.c:			if (!wavefront_fx_idle (dev)) {
sound/isa/wavefront/wavefront_fx.c:snd_wavefront_fx_detect (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_fx.c:	   Certainly on the Maui and the Tropez, wavefront_fx_idle() will
sound/isa/wavefront/wavefront_fx.c:snd_wavefront_fx_open (struct snd_hwdep *hw, struct file *file)
sound/isa/wavefront/wavefront_fx.c:snd_wavefront_fx_release (struct snd_hwdep *hw, struct file *file)
sound/isa/wavefront/wavefront_fx.c:snd_wavefront_fx_ioctl (struct snd_hwdep *sdev, struct file *file,
sound/isa/wavefront/wavefront_fx.c:	snd_wavefront_card_t *acard;
sound/isa/wavefront/wavefront_fx.c:	snd_wavefront_t *dev;
sound/isa/wavefront/wavefront_fx.c:	wavefront_fx_info r;
sound/isa/wavefront/wavefront_fx.c:	dev = &acard->wavefront;
sound/isa/wavefront/wavefront_fx.c:	if (copy_from_user (&r, (void __user *)arg, sizeof (wavefront_fx_info)))
sound/isa/wavefront/wavefront_fx.c:		wavefront_fx_mute (dev, r.data[0]);
sound/isa/wavefront/wavefront_fx.c:		err = wavefront_fx_memset (dev,
sound/isa/wavefront/wavefront_fx.c:snd_wavefront_fx_start (snd_wavefront_t *dev)
sound/isa/wavefront/wavefront_fx.c:			if (!wavefront_fx_idle(dev)) {
sound/isa/wavefront/wavefront.c:#include <sound/snd_wavefront.h>
sound/isa/wavefront/wavefront.c:static struct pnp_card_device_id snd_wavefront_pnpids[] = {
sound/isa/wavefront/wavefront.c:MODULE_DEVICE_TABLE(pnp_card, snd_wavefront_pnpids);
sound/isa/wavefront/wavefront.c:snd_wavefront_pnp (int dev, snd_wavefront_card_t *acard, struct pnp_card_link *card,
sound/isa/wavefront/wavefront.c:static irqreturn_t snd_wavefront_ics2115_interrupt(int irq, void *dev_id)
sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard;
sound/isa/wavefront/wavefront.c:	acard = (snd_wavefront_card_t *) dev_id;
sound/isa/wavefront/wavefront.c:	if (acard->wavefront.interrupts_are_midi) {
sound/isa/wavefront/wavefront.c:		snd_wavefront_midi_interrupt (acard);
sound/isa/wavefront/wavefront.c:		snd_wavefront_internal_interrupt (acard);
sound/isa/wavefront/wavefront.c:snd_wavefront_new_synth (struct snd_card *card,
sound/isa/wavefront/wavefront.c:			 snd_wavefront_card_t *acard)
sound/isa/wavefront/wavefront.c:	struct snd_hwdep *wavefront_synth;
sound/isa/wavefront/wavefront.c:	if (snd_wavefront_detect (acard) < 0) {
sound/isa/wavefront/wavefront.c:	if (snd_wavefront_start (&acard->wavefront) < 0) {
sound/isa/wavefront/wavefront.c:	if (snd_hwdep_new(card, "WaveFront", hw_dev, &wavefront_synth) < 0)
sound/isa/wavefront/wavefront.c:	strcpy (wavefront_synth->name, 
sound/isa/wavefront/wavefront.c:		"WaveFront (ICS2115) wavetable synthesizer");
sound/isa/wavefront/wavefront.c:	wavefront_synth->ops.open = snd_wavefront_synth_open;
sound/isa/wavefront/wavefront.c:	wavefront_synth->ops.release = snd_wavefront_synth_release;
sound/isa/wavefront/wavefront.c:	wavefront_synth->ops.ioctl = snd_wavefront_synth_ioctl;
sound/isa/wavefront/wavefront.c:	return wavefront_synth;
sound/isa/wavefront/wavefront.c:snd_wavefront_new_fx (struct snd_card *card,
sound/isa/wavefront/wavefront.c:		      snd_wavefront_card_t *acard,
sound/isa/wavefront/wavefront.c:	if (snd_wavefront_fx_start (&acard->wavefront)) {
sound/isa/wavefront/wavefront.c:	fx_processor->ops.open = snd_wavefront_fx_open;
sound/isa/wavefront/wavefront.c:	fx_processor->ops.release = snd_wavefront_fx_release;
sound/isa/wavefront/wavefront.c:	fx_processor->ops.ioctl = snd_wavefront_fx_ioctl;
sound/isa/wavefront/wavefront.c:static snd_wavefront_mpu_id internal_id = internal_mpu;
sound/isa/wavefront/wavefront.c:static snd_wavefront_mpu_id external_id = external_mpu;
sound/isa/wavefront/wavefront.c:snd_wavefront_new_midi (struct snd_card *card,
sound/isa/wavefront/wavefront.c:			snd_wavefront_card_t *acard,
sound/isa/wavefront/wavefront.c:			snd_wavefront_mpu_id mpu)
sound/isa/wavefront/wavefront.c:		acard->wavefront.midi.base = port;
sound/isa/wavefront/wavefront.c:		if (snd_wavefront_midi_start (acard)) {
sound/isa/wavefront/wavefront.c:	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_wavefront_midi_output);
sound/isa/wavefront/wavefront.c:	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_wavefront_midi_input);
sound/isa/wavefront/wavefront.c:snd_wavefront_free(struct snd_card *card)
sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard = (snd_wavefront_card_t *)card->private_data;
sound/isa/wavefront/wavefront.c:		release_and_free_resource(acard->wavefront.res_base);
sound/isa/wavefront/wavefront.c:		if (acard->wavefront.irq > 0)
sound/isa/wavefront/wavefront.c:			free_irq(acard->wavefront.irq, (void *)acard);
sound/isa/wavefront/wavefront.c:static int snd_wavefront_card_new(int dev, struct snd_card **cardp)
sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard;
sound/isa/wavefront/wavefront.c:			      sizeof(snd_wavefront_card_t), &card);
sound/isa/wavefront/wavefront.c:	acard->wavefront.irq = -1;
sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.irq_lock);
sound/isa/wavefront/wavefront.c:	init_waitqueue_head(&acard->wavefront.interrupt_sleeper);
sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.midi.open);
sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.midi.virtual);
sound/isa/wavefront/wavefront.c:	acard->wavefront.card = card;
sound/isa/wavefront/wavefront.c:	card->private_free = snd_wavefront_free;
sound/isa/wavefront/wavefront.c:snd_wavefront_probe (struct snd_card *card, int dev)
sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard = card->private_data;
sound/isa/wavefront/wavefront.c:	struct snd_hwdep *wavefront_synth;
sound/isa/wavefront/wavefront.c:	acard->wavefront.res_base = request_region(ics2115_port[dev], 16,
sound/isa/wavefront/wavefront.c:	if (acard->wavefront.res_base == NULL) {
sound/isa/wavefront/wavefront.c:	if (request_irq(ics2115_irq[dev], snd_wavefront_ics2115_interrupt,
sound/isa/wavefront/wavefront.c:	acard->wavefront.irq = ics2115_irq[dev];
sound/isa/wavefront/wavefront.c:	acard->wavefront.base = ics2115_port[dev];
sound/isa/wavefront/wavefront.c:	wavefront_synth = snd_wavefront_new_synth(card, hw_dev, acard);
sound/isa/wavefront/wavefront.c:	if (wavefront_synth == NULL) {
sound/isa/wavefront/wavefront.c:	strcpy (wavefront_synth->name, "ICS2115 Wavetable MIDI Synthesizer");
sound/isa/wavefront/wavefront.c:	wavefront_synth->iface = SNDRV_HWDEP_IFACE_ICS2115;
sound/isa/wavefront/wavefront.c:			snd_wavefront_new_midi (card, 
sound/isa/wavefront/wavefront.c:			snd_wavefront_new_midi (card, 
sound/isa/wavefront/wavefront.c:	if (acard->wavefront.has_fx) {
sound/isa/wavefront/wavefront.c:		fx_processor = snd_wavefront_new_fx (card,
sound/isa/wavefront/wavefront.c:static int __devinit snd_wavefront_isa_match(struct device *pdev,
sound/isa/wavefront/wavefront.c:static int __devinit snd_wavefront_isa_probe(struct device *pdev,
sound/isa/wavefront/wavefront.c:	err = snd_wavefront_card_new(dev, &card);
sound/isa/wavefront/wavefront.c:	if ((err = snd_wavefront_probe(card, dev)) < 0) {
sound/isa/wavefront/wavefront.c:static int __devexit snd_wavefront_isa_remove(struct device *devptr,
sound/isa/wavefront/wavefront.c:#define DEV_NAME "wavefront"
sound/isa/wavefront/wavefront.c:static struct isa_driver snd_wavefront_driver = {
sound/isa/wavefront/wavefront.c:	.match		= snd_wavefront_isa_match,
sound/isa/wavefront/wavefront.c:	.probe		= snd_wavefront_isa_probe,
sound/isa/wavefront/wavefront.c:	.remove		= __devexit_p(snd_wavefront_isa_remove),
sound/isa/wavefront/wavefront.c:static int __devinit snd_wavefront_pnp_detect(struct pnp_card_link *pcard,
sound/isa/wavefront/wavefront.c:	res = snd_wavefront_card_new(dev, &card);
sound/isa/wavefront/wavefront.c:	if (snd_wavefront_pnp (dev, card->private_data, pcard, pid) < 0) {
sound/isa/wavefront/wavefront.c:	if ((res = snd_wavefront_probe(card, dev)) < 0)
sound/isa/wavefront/wavefront.c:static void __devexit snd_wavefront_pnp_remove(struct pnp_card_link * pcard)
sound/isa/wavefront/wavefront.c:static struct pnp_card_driver wavefront_pnpc_driver = {
sound/isa/wavefront/wavefront.c:	.name		= "wavefront",
sound/isa/wavefront/wavefront.c:	.id_table	= snd_wavefront_pnpids,
sound/isa/wavefront/wavefront.c:	.probe		= snd_wavefront_pnp_detect,
sound/isa/wavefront/wavefront.c:	.remove		= __devexit_p(snd_wavefront_pnp_remove),
sound/isa/wavefront/wavefront.c:static int __init alsa_card_wavefront_init(void)
sound/isa/wavefront/wavefront.c:	err = isa_register_driver(&snd_wavefront_driver, SNDRV_CARDS);
sound/isa/wavefront/wavefront.c:	err = pnp_register_card_driver(&wavefront_pnpc_driver);
sound/isa/wavefront/wavefront.c:static void __exit alsa_card_wavefront_exit(void)
sound/isa/wavefront/wavefront.c:		pnp_unregister_card_driver(&wavefront_pnpc_driver);
sound/isa/wavefront/wavefront.c:		isa_unregister_driver(&snd_wavefront_driver);
sound/isa/wavefront/wavefront.c:module_init(alsa_card_wavefront_init)
sound/isa/wavefront/wavefront.c:module_exit(alsa_card_wavefront_exit)
sound/isa/wavefront/wavefront_midi.c: * NOTE: VIRTUAL MIDI MODE IS ON BY DEFAULT (see lowlevel/isa/wavefront.c)
sound/isa/wavefront/wavefront_midi.c:#include <sound/snd_wavefront.h>
sound/isa/wavefront/wavefront_midi.c:wf_mpu_status (snd_wavefront_midi_t *midi)
sound/isa/wavefront/wavefront_midi.c:input_avail (snd_wavefront_midi_t *midi)
sound/isa/wavefront/wavefront_midi.c:output_ready (snd_wavefront_midi_t *midi)
sound/isa/wavefront/wavefront_midi.c:read_data (snd_wavefront_midi_t *midi)
sound/isa/wavefront/wavefront_midi.c:write_data (snd_wavefront_midi_t *midi, unsigned char byte)
sound/isa/wavefront/wavefront_midi.c:static snd_wavefront_midi_t *
sound/isa/wavefront/wavefront_midi.c:get_wavefront_midi (struct snd_rawmidi_substream *substream)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_card_t *acard;
sound/isa/wavefront/wavefront_midi.c:	return &acard->wavefront.midi;
sound/isa/wavefront/wavefront_midi.c:static void snd_wavefront_midi_output_write(snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi = &card->wavefront.midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id  mpu;
sound/isa/wavefront/wavefront_midi.c:	   snd_wavefront_midi_{enable,disable}_virtual () for the
sound/isa/wavefront/wavefront_midi.c:static int snd_wavefront_midi_input_open(struct snd_rawmidi_substream *substream)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL)
sound/isa/wavefront/wavefront_midi.c:static int snd_wavefront_midi_output_open(struct snd_rawmidi_substream *substream)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL)
sound/isa/wavefront/wavefront_midi.c:static int snd_wavefront_midi_input_close(struct snd_rawmidi_substream *substream)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL)
sound/isa/wavefront/wavefront_midi.c:static int snd_wavefront_midi_output_close(struct snd_rawmidi_substream *substream)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL)
sound/isa/wavefront/wavefront_midi.c:static void snd_wavefront_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL) {
sound/isa/wavefront/wavefront_midi.c:static void snd_wavefront_midi_output_timer(unsigned long data)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_card_t *card = (snd_wavefront_card_t *)data;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi = &card->wavefront.midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_output_write(card);
sound/isa/wavefront/wavefront_midi.c:static void snd_wavefront_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_mpu_id mpu;
sound/isa/wavefront/wavefront_midi.c:	mpu = *((snd_wavefront_mpu_id *) substream->rmidi->private_data);
sound/isa/wavefront/wavefront_midi.c:	if ((midi = get_wavefront_midi (substream)) == NULL) {
sound/isa/wavefront/wavefront_midi.c:				midi->timer.function = snd_wavefront_midi_output_timer;
sound/isa/wavefront/wavefront_midi.c:		snd_wavefront_midi_output_write((snd_wavefront_card_t *)substream->rmidi->card->private_data);
sound/isa/wavefront/wavefront_midi.c:snd_wavefront_midi_interrupt (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	midi = &card->wavefront.midi;
sound/isa/wavefront/wavefront_midi.c:		snd_wavefront_midi_output_write(card);
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_output_write(card);
sound/isa/wavefront/wavefront_midi.c:snd_wavefront_midi_enable_virtual (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_midi.c:	spin_lock_irqsave (&card->wavefront.midi.virtual, flags);
sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.isvirtual = 1;
sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.output_mpu = internal_mpu;
sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.input_mpu = internal_mpu;
sound/isa/wavefront/wavefront_midi.c:	spin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);
sound/isa/wavefront/wavefront_midi.c:snd_wavefront_midi_disable_virtual (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_midi.c:	spin_lock_irqsave (&card->wavefront.midi.virtual, flags);
sound/isa/wavefront/wavefront_midi.c:	// snd_wavefront_midi_input_close (card->ics2115_external_rmidi);
sound/isa/wavefront/wavefront_midi.c:	// snd_wavefront_midi_output_close (card->ics2115_external_rmidi);
sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.isvirtual = 0;
sound/isa/wavefront/wavefront_midi.c:	spin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);
sound/isa/wavefront/wavefront_midi.c:snd_wavefront_midi_start (snd_wavefront_card_t *card)
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_t *dev;
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi;
sound/isa/wavefront/wavefront_midi.c:	dev = &card->wavefront;
sound/isa/wavefront/wavefront_midi.c:	if (snd_wavefront_cmd (dev, WFC_MISYNTH_ON, rbuf, wbuf)) {
sound/isa/wavefront/wavefront_midi.c:	if (snd_wavefront_cmd (dev, WFC_VMIDI_OFF, rbuf, wbuf)) { 
sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_enable_virtual (card);
sound/isa/wavefront/wavefront_midi.c:	if (snd_wavefront_cmd (dev, WFC_VMIDI_ON, rbuf, wbuf)) {
sound/isa/wavefront/wavefront_midi.c:		snd_wavefront_midi_disable_virtual (card);
sound/isa/wavefront/wavefront_midi.c:struct snd_rawmidi_ops snd_wavefront_midi_output =
sound/isa/wavefront/wavefront_midi.c:	.open =		snd_wavefront_midi_output_open,
sound/isa/wavefront/wavefront_midi.c:	.close =	snd_wavefront_midi_output_close,
sound/isa/wavefront/wavefront_midi.c:	.trigger =	snd_wavefront_midi_output_trigger,
sound/isa/wavefront/wavefront_midi.c:struct snd_rawmidi_ops snd_wavefront_midi_input =
sound/isa/wavefront/wavefront_midi.c:	.open =		snd_wavefront_midi_input_open,
sound/isa/wavefront/wavefront_midi.c:	.close =	snd_wavefront_midi_input_close,
sound/isa/wavefront/wavefront_midi.c:	.trigger =	snd_wavefront_midi_input_trigger,
sound/isa/opti9xx/opti92x-ad1848.c:		/* enable wave audio */
sound/isa/opti9xx/opti92x-ad1848.c:		 * The BTC 1817DW has QS1000 wavetable which is connected
sound/isa/es18xx.c:		/* Enable ESS wavetable input */
sound/isa/cs423x/cs4236_lib.c: *  C8  wavetable control
sound/isa/cs423x/cs4236_lib.c: *     D3: wavetable serial port enable (all chips)
sound/isa/cmi8330.c:	0x0,			/* 22 - wave volume */
sound/isa/cmi8330.c:	0x0,			/* 24 - wave rec gain */
sound/isa/gus/gus_main.c:	if (!gus->interwave) {
sound/isa/gus/gus_reset.c:static void snd_gf1_default_interrupt_handler_wave_and_volume(struct snd_gus_card * gus, struct snd_gus_voice * voice)
sound/isa/gus/gus_reset.c:		voice->handler_wave =
sound/isa/gus/gus_reset.c:		voice->handler_volume = snd_gf1_default_interrupt_handler_wave_and_volume;
sound/isa/gus/gus_reset.c:		snd_gf1_i_write16(gus, SNDRV_GF1_GW_FIFO_SIZE, gus->chip.interwave_fifo_reg);
sound/isa/gus/Makefile:snd-interwave-objs := interwave.o
sound/isa/gus/Makefile:snd-interwave-stb-objs := interwave-stb.o
sound/isa/gus/Makefile:obj-$(CONFIG_SND_INTERWAVE) += snd-interwave.o snd-gus-lib.o
sound/isa/gus/Makefile:obj-$(CONFIG_SND_INTERWAVE_STB) += snd-interwave-stb.o snd-gus-lib.o
sound/isa/gus/gus_irq.c:					STAT_ADD(pvoice->interrupt_stat_wave);
sound/isa/gus/gus_irq.c:					pvoice->handler_wave(gus, pvoice);
sound/isa/gus/gus_irq.c:		snd_iprintf(buffer, "voice %i: wave = %u, volume = %u\n",
sound/isa/gus/gus_irq.c:					pvoice->interrupt_stat_wave,
sound/isa/gus/gus_pcm.c:static void snd_gf1_pcm_interrupt_wave(struct snd_gus_card * gus,
sound/isa/gus/gus_pcm.c:		snd_printd("snd_gf1_pcm: unknown wave irq?\n");
sound/isa/gus/gus_pcm.c:		snd_printd("snd_gf1_pcm: unknown wave irq?\n");
sound/isa/gus/gus_pcm.c:		if (gus->interwave) {
sound/isa/gus/gus_pcm.c:		pcmp->pvoices[0]->handler_wave = snd_gf1_pcm_interrupt_wave;
sound/isa/gus/gus_pcm.c:		pcmp->pvoices[1]->handler_wave = snd_gf1_pcm_interrupt_wave;
sound/isa/gus/gus_pcm.c:	capture = !gus->interwave && !gus->ess_flag && !gus->ace_flag ? 1 : 0;
sound/isa/gus/gus_pcm.c:			  gus->interwave ? "AMD InterWave" : "GF1",
sound/isa/gus/gus_pcm.c:	if (gus->interwave) {
sound/isa/gus/gus_dram.c:		if (gus->interwave) {
sound/isa/gus/gus_dram.c:		if (gus->interwave) {
sound/isa/gus/interwave-stb.c:#include "interwave.c"
sound/isa/gus/gus_mem.c:			snd_iprintf(buffer, "SIMPLE wave\n");
sound/isa/gus/gus_mem.c:			snd_iprintf(buffer, "GF1 wave\n");
sound/isa/gus/gus_mem.c:			snd_iprintf(buffer, "IWFFFF wave\n");
sound/isa/gus/gus_io.c: *  ok.. stop of control registers (wave & ramp) need some special things..
sound/isa/gus/gus_io.c:	if (!gus->interwave)
sound/isa/gus/gus_io.c:	if (!gus->interwave)
sound/isa/gus/gus_io.c:	if (!gus->interwave)
sound/isa/gus/gus_io.c:	if (gus->interwave && snd_gf1_i_read8(gus, 0x19) & 0x01) {	/* enhanced mode */
sound/isa/gus/gus_io.c:	if (gus->interwave) {
sound/isa/gus/gus_io.c:	if (!gus->interwave)
sound/isa/gus/gus_io.c:	if (gus->interwave) {
sound/isa/gus/interwave.c:#define PFX "interwave-stb: "
sound/isa/gus/interwave.c:#define INTERWAVE_DRIVER	"snd_interwave_stb"
sound/isa/gus/interwave.c:#define INTERWAVE_PNP_DRIVER	"interwave-stb"
sound/isa/gus/interwave.c:#define PFX "interwave: "
sound/isa/gus/interwave.c:#define INTERWAVE_DRIVER	"snd_interwave"
sound/isa/gus/interwave.c:#define INTERWAVE_PNP_DRIVER	"interwave"
sound/isa/gus/interwave.c:struct snd_interwave {
sound/isa/gus/interwave.c:static struct pnp_card_device_id snd_interwave_pnpids[] = {
sound/isa/gus/interwave.c:MODULE_DEVICE_TABLE(pnp_card, snd_interwave_pnpids);
sound/isa/gus/interwave.c:static void snd_interwave_i2c_setlines(struct snd_i2c_bus *bus, int ctrl, int data)
sound/isa/gus/interwave.c:static int snd_interwave_i2c_getclockline(struct snd_i2c_bus *bus)
sound/isa/gus/interwave.c:static int snd_interwave_i2c_getdataline(struct snd_i2c_bus *bus, int ack)
sound/isa/gus/interwave.c:static struct snd_i2c_bit_ops snd_interwave_i2c_bit_ops = {
sound/isa/gus/interwave.c:	.setlines = snd_interwave_i2c_setlines,
sound/isa/gus/interwave.c:	.getclock = snd_interwave_i2c_getclockline,
sound/isa/gus/interwave.c:	.getdata  = snd_interwave_i2c_getdataline,
sound/isa/gus/interwave.c:static int __devinit snd_interwave_detect_stb(struct snd_interwave *iwcard,
sound/isa/gus/interwave.c:		snd_printk(KERN_ERR "interwave: can't grab i2c bus port\n");
sound/isa/gus/interwave.c:	bus->hw_ops.bit = &snd_interwave_i2c_bit_ops;
sound/isa/gus/interwave.c:static int __devinit snd_interwave_detect(struct snd_interwave *iwcard,
sound/isa/gus/interwave.c:		gus->interwave = 1;
sound/isa/gus/interwave.c:		return snd_interwave_detect_stb(iwcard, gus, dev, rbus);
sound/isa/gus/interwave.c:static irqreturn_t snd_interwave_interrupt(int irq, void *dev_id)
sound/isa/gus/interwave.c:	struct snd_interwave *iwcard = dev_id;
sound/isa/gus/interwave.c:static void __devinit snd_interwave_reset(struct snd_gus_card * gus)
sound/isa/gus/interwave.c:static void __devinit snd_interwave_bank_sizes(struct snd_gus_card * gus, int *sizes)
sound/isa/gus/interwave.c:	/* 000 */ unsigned char iwave[8];
sound/isa/gus/interwave.c:static void __devinit snd_interwave_detect_memory(struct snd_gus_card * gus)
sound/isa/gus/interwave.c:	unsigned char iwave[8];
sound/isa/gus/interwave.c:	snd_interwave_reset(gus);
sound/isa/gus/interwave.c:		snd_interwave_bank_sizes(gus, psizes);
sound/isa/gus/interwave.c:				snd_interwave_bank_sizes(gus, psizes);
sound/isa/gus/interwave.c:			iwave[i] = snd_gf1_peek(gus, bank_pos + i);
sound/isa/gus/interwave.c:		       iwave[0], iwave[1], iwave[2], iwave[3],
sound/isa/gus/interwave.c:		       iwave[4], iwave[5], iwave[6], iwave[7]);
sound/isa/gus/interwave.c:		if (strncmp(iwave, "INTRWAVE", 8))
sound/isa/gus/interwave.c:		snd_interwave_reset(gus);
sound/isa/gus/interwave.c:static void __devinit snd_interwave_init(int dev, struct snd_gus_card * gus)
sound/isa/gus/interwave.c:	gus->interwave = 1;
sound/isa/gus/interwave.c:static struct snd_kcontrol_new snd_interwave_controls[] = {
sound/isa/gus/interwave.c:static int __devinit snd_interwave_mixer(struct snd_wss *chip)
sound/isa/gus/interwave.c:	for (idx = 0; idx < ARRAY_SIZE(snd_interwave_controls); idx++)
sound/isa/gus/interwave.c:		if ((err = snd_ctl_add(card, snd_ctl_new1(&snd_interwave_controls[idx], chip))) < 0)
sound/isa/gus/interwave.c:static int __devinit snd_interwave_pnp(int dev, struct snd_interwave *iwcard,
sound/isa/gus/interwave.c:static void snd_interwave_free(struct snd_card *card)
sound/isa/gus/interwave.c:	struct snd_interwave *iwcard = card->private_data;
sound/isa/gus/interwave.c:static int snd_interwave_card_new(int dev, struct snd_card **cardp)
sound/isa/gus/interwave.c:	struct snd_interwave *iwcard;
sound/isa/gus/interwave.c:			      sizeof(struct snd_interwave), &card);
sound/isa/gus/interwave.c:	card->private_free = snd_interwave_free;
sound/isa/gus/interwave.c:static int __devinit snd_interwave_probe(struct snd_card *card, int dev)
sound/isa/gus/interwave.c:	struct snd_interwave *iwcard = card->private_data;
sound/isa/gus/interwave.c:	if ((err = snd_interwave_detect(iwcard, gus, dev
sound/isa/gus/interwave.c:	snd_interwave_init(dev, gus);
sound/isa/gus/interwave.c:	snd_interwave_detect_memory(gus);
sound/isa/gus/interwave.c:	if (request_irq(xirq, snd_interwave_interrupt, IRQF_DISABLED,
sound/isa/gus/interwave.c:	err = snd_interwave_mixer(wss);
sound/isa/gus/interwave.c:static int __devinit snd_interwave_isa_probe1(int dev, struct device *devptr)
sound/isa/gus/interwave.c:	err = snd_interwave_card_new(dev, &card);
sound/isa/gus/interwave.c:	if ((err = snd_interwave_probe(card, dev)) < 0) {
sound/isa/gus/interwave.c:static int __devinit snd_interwave_isa_match(struct device *pdev,
sound/isa/gus/interwave.c:static int __devinit snd_interwave_isa_probe(struct device *pdev,
sound/isa/gus/interwave.c:		return snd_interwave_isa_probe1(dev, pdev);
sound/isa/gus/interwave.c:			err = snd_interwave_isa_probe1(dev, pdev);
sound/isa/gus/interwave.c:static int __devexit snd_interwave_isa_remove(struct device *devptr, unsigned int dev)
sound/isa/gus/interwave.c:static struct isa_driver snd_interwave_driver = {
sound/isa/gus/interwave.c:	.match		= snd_interwave_isa_match,
sound/isa/gus/interwave.c:	.probe		= snd_interwave_isa_probe,
sound/isa/gus/interwave.c:	.remove		= __devexit_p(snd_interwave_isa_remove),
sound/isa/gus/interwave.c:static int __devinit snd_interwave_pnp_detect(struct pnp_card_link *pcard,
sound/isa/gus/interwave.c:	res = snd_interwave_card_new(dev, &card);
sound/isa/gus/interwave.c:	if ((res = snd_interwave_pnp(dev, card->private_data, pcard, pid)) < 0) {
sound/isa/gus/interwave.c:	if ((res = snd_interwave_probe(card, dev)) < 0) {
sound/isa/gus/interwave.c:static void __devexit snd_interwave_pnp_remove(struct pnp_card_link * pcard)
sound/isa/gus/interwave.c:static struct pnp_card_driver interwave_pnpc_driver = {
sound/isa/gus/interwave.c:	.id_table = snd_interwave_pnpids,
sound/isa/gus/interwave.c:	.probe = snd_interwave_pnp_detect,
sound/isa/gus/interwave.c:	.remove = __devexit_p(snd_interwave_pnp_remove),
sound/isa/gus/interwave.c:static int __init alsa_card_interwave_init(void)
sound/isa/gus/interwave.c:	err = isa_register_driver(&snd_interwave_driver, SNDRV_CARDS);
sound/isa/gus/interwave.c:	err = pnp_register_card_driver(&interwave_pnpc_driver);
sound/isa/gus/interwave.c:static void __exit alsa_card_interwave_exit(void)
sound/isa/gus/interwave.c:		pnp_unregister_card_driver(&interwave_pnpc_driver);
sound/isa/gus/interwave.c:		isa_unregister_driver(&snd_interwave_driver);
sound/isa/gus/interwave.c:module_init(alsa_card_interwave_init)
sound/isa/gus/interwave.c:module_exit(alsa_card_interwave_exit)
sound/isa/gus/gus_instr.c:int snd_gus_iwffff_put_sample(void *private_data, struct iwffff_wave *wave,
sound/isa/gus/gus_instr.c:	if (wave->format & IWFFFF_WAVE_ROM)
sound/isa/gus/gus_instr.c:	if (wave->format & IWFFFF_WAVE_STEREO)
sound/isa/gus/gus_instr.c:				  NULL, wave->size,
sound/isa/gus/gus_instr.c:				  wave->format & IWFFFF_WAVE_16BIT, 1,
sound/isa/gus/gus_instr.c:				  wave->share_id);
sound/isa/gus/gus_instr.c:				 block->ptr, wave->size);
sound/isa/gus/gus_instr.c:	wave->address.memory = block->ptr;
sound/isa/gus/gus_instr.c:int snd_gus_iwffff_get_sample(void *private_data, struct iwffff_wave *wave,
sound/isa/gus/gus_instr.c:	return snd_gus_dram_read(gus, data, wave->address.memory, wave->size,
sound/isa/gus/gus_instr.c:				 wave->format & IWFFFF_WAVE_ROM ? 1 : 0);
sound/isa/gus/gus_instr.c:int snd_gus_iwffff_remove_sample(void *private_data, struct iwffff_wave *wave,
sound/isa/gus/gus_instr.c:	if (wave->format & IWFFFF_WAVE_ROM)
sound/isa/gus/gus_instr.c:	return snd_gf1_mem_free(&gus->gf1.mem_alloc, wave->address.memory);
sound/isa/gus/gus_instr.c:int snd_gus_gf1_put_sample(void *private_data, struct gf1_wave *wave,
sound/isa/gus/gus_instr.c:	if (wave->format & GF1_WAVE_STEREO)
sound/isa/gus/gus_instr.c:				  NULL, wave->size,
sound/isa/gus/gus_instr.c:				  wave->format & GF1_WAVE_16BIT, 1,
sound/isa/gus/gus_instr.c:				  wave->share_id);
sound/isa/gus/gus_instr.c:				 block->ptr, wave->size);
sound/isa/gus/gus_instr.c:	wave->address.memory = block->ptr;
sound/isa/gus/gus_instr.c:int snd_gus_gf1_get_sample(void *private_data, struct gf1_wave *wave,
sound/isa/gus/gus_instr.c:	return snd_gus_dram_read(gus, data, wave->address.memory, wave->size, 0);
sound/isa/gus/gus_instr.c:int snd_gus_gf1_remove_sample(void *private_data, struct gf1_wave *wave,
sound/isa/gus/gus_instr.c:	return snd_gf1_mem_free(&gus->gf1.mem_alloc, wave->address.memory);
sound/isa/gus/gus_uart.c:	strcpy(rmidi->name, gus->interwave ? "AMD InterWave" : "GF1");
sound/pci/cs4281.c:#define BA0_SSCR_HVS1		(1<<23)	/* Hardwave Volume Step (0=1,1=2) */
sound/pci/cs4281.c:		/* Leave wave playback FIFO enabled for FM */
sound/pci/cs4281.c:	/* Deactivate wave playback FIFO before changing slot assignments */
sound/pci/cs4281.c:	/* Activate wave playback FIFO for FM playback */
sound/pci/ad1889.h:#define AD_DS_WSMC	0x00 /* wave/synthesis channel mixer control */
sound/pci/ad1889.h:#define  AD_DS_WSMC_WA16 0x0100 /* wave channel 16bit select */
sound/pci/ad1889.h:#define  AD_DS_WSMC_WAST 0x0200 /* wave channel stereo select */
sound/pci/ad1889.h:#define  AD_DS_WSMC_WAEN 0x0400 /* wave channel enable */
sound/pci/ad1889.h:#define  AD_DS_WSMC_WARQ 0x3000 /* wave fifo request point */
sound/pci/ad1889.h:#define AD_DS_WADA	0x04 /* wave channel mix attenuation */
sound/pci/ad1889.h:#define  AD_DS_WADA_RWAM 0x0080 /* right wave mute */
sound/pci/ad1889.h:#define  AD_DS_WADA_RWAA 0x001f /* right wave attenuation */
sound/pci/ad1889.h:#define  AD_DS_WADA_LWAM 0x8000 /* left wave mute */
sound/pci/ad1889.h:#define  AD_DS_WADA_LWAA 0x3e00 /* left wave attenuation */
sound/pci/ad1889.h:#define AD_DS_WAS	0x08 /* wave channel sample rate */
sound/pci/ad1889.h:#define  AD_DS_CCS_WAU   0x0008 /* wave channel underflow */
sound/pci/ad1889.h:#define AD_DMA_WAVBA	0x70 /* wave base address */
sound/pci/ad1889.h:#define AD_DMA_WAVCA	0x74 /* wave current address */
sound/pci/ad1889.h:#define AD_DMA_WAVBC	0x78 /* wave base count */
sound/pci/ad1889.h:#define AD_DMA_WAVCC	0x7c /* wave current count */
sound/pci/ad1889.h:#define AD_DMA_WAVIC	0x98 /* wave dma interrupt current byte count */
sound/pci/ad1889.h:#define AD_DMA_WAVIB	0x9c /* wave dma interrupt base byte count */
sound/pci/ad1889.h:#define AD_DMA_WAV	0xb8	/* wave     dma control and status */
sound/pci/ad1889.h:#define  AD_DMA_DISR_WAVI 0x000008 /* wave channel interrupt */
sound/pci/ad1889.h:#define  AD_DMA_CHSS_WAVS 0x000008 /* wave channel stopped */
sound/pci/au88x0/au8830.h:#define VORTEX_MIX_SMP 0x21c00	/* wave data buffers. AU8820: 0x9c00 */
sound/pci/au88x0/au88x0.c:			       sizeof(snd_vortex_synth_arg_t), &wave) < 0
sound/pci/au88x0/au88x0.c:	    || wave == NULL) {
sound/pci/au88x0/au88x0.c:		snd_printk(KERN_ERR "Can't initialize Aureal wavetable synth\n");
sound/pci/au88x0/au88x0.c:		arg = SNDRV_SEQ_DEVICE_ARGPTR(wave);
sound/pci/au88x0/au88x0.c:		strcpy(wave->name, "Aureal Synth");
sound/pci/emu10k1/emu10k1_synth_local.h: *  Local defininitons for Emu10k1 wavetable
sound/pci/emu10k1/emu10k1.c:	struct snd_seq_device *wave = NULL;
sound/pci/emu10k1/emu10k1.c:			       sizeof(struct snd_emu10k1_synth_arg), &wave) < 0 ||
sound/pci/emu10k1/emu10k1.c:	    wave == NULL) {
sound/pci/emu10k1/emu10k1.c:		snd_printk(KERN_WARNING "can't initialize Emu10k1 wavetable synth\n");
sound/pci/emu10k1/emu10k1.c:		arg = SNDRV_SEQ_DEVICE_ARGPTR(wave);
sound/pci/emu10k1/emu10k1.c:		strcpy(wave->name, "Emu-10k1 Synth");
sound/pci/cmipci.c:#define CM_DAC2SPDO		0x00200000	/* enable wave+fm_midi -> SPDIF/OUT */
sound/pci/cmipci.c:#define CM_WAVEINL		0x08	/* digital wave rec. left chan */
sound/pci/cmipci.c:#define CM_WAVEINR		0x04	/* digical wave rec. right */
sound/pci/sonicvibes.c:#define   SV_WAVETABLE	  0x08	/* wavetable active / FM active if not set */
sound/pci/sonicvibes.c:	unsigned char wave_source;
sound/pci/sonicvibes.c:	printk("  0x2e: wave source     = 0x%02x\n", snd_sonicvibes_in(sonic, 0x2e));
sound/pci/sonicvibes.c:	tmp = sonic->wave_source & 0x03;
sound/pci/sonicvibes.c:	snd_sonicvibes_out(sonic, SV_IREG_WAVE_SOURCE, sonic->wave_source = 0x00);	/* onboard ROM */
sound/pci/ad1889.c:	struct ad1889_register_state wave;
sound/pci/ad1889.c:ad1889_load_wave_buffer_address(struct snd_ad1889 *chip, u32 address)
sound/pci/ad1889.c:ad1889_load_wave_buffer_count(struct snd_ad1889 *chip, u32 count)
sound/pci/ad1889.c:ad1889_load_wave_interrupt_count(struct snd_ad1889 *chip, u32 count)
sound/pci/ad1889.c:		/* Disable wave channel */
sound/pci/ad1889.c:		chip->wave.reg = reg;
sound/pci/ad1889.c:		ad1889_load_wave_buffer_address(chip, 0x0);
sound/pci/ad1889.c:		ad1889_load_wave_buffer_count(chip, 0x0);
sound/pci/ad1889.c:		ad1889_load_wave_interrupt_count(chip, 0x0);
sound/pci/ad1889.c:	chip->wave.size = size;
sound/pci/ad1889.c:	chip->wave.reg = reg;
sound/pci/ad1889.c:	chip->wave.addr = rt->dma_addr;
sound/pci/ad1889.c:	ad1889_writew(chip, AD_DS_WSMC, chip->wave.reg);
sound/pci/ad1889.c:	ad1889_load_wave_buffer_address(chip, chip->wave.addr);
sound/pci/ad1889.c:	ad1889_load_wave_buffer_count(chip, size);
sound/pci/ad1889.c:	ad1889_load_wave_interrupt_count(chip, count);
sound/pci/ad1889.c:			"size = %u, reg = 0x%x, rate = %u\n", chip->wave.addr,
sound/pci/ad1889.c:	chip->wave.reg = wsmc;
sound/pci/ad1889.c:	if (unlikely(!(chip->wave.reg & AD_DS_WSMC_WAEN)))
sound/pci/ad1889.c:	ptr -= chip->wave.addr;
sound/pci/ad1889.c:	if (snd_BUG_ON(ptr >= chip->wave.size))
sound/pci/sis7019.c:	void __iomem *wave_base;
sound/pci/sis7019.c:/* We need four pages to store our wave parameters during a suspend. If
sound/pci/sis7019.c:	/* Allocate pages to store the internal wave state during
sound/pci/sis7019.c:	void __iomem *wave_base = voice->wave_base;
sound/pci/sis7019.c:		writel(0, wave_base + reg);
sound/pci/sis7019.c:	writel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);
sound/pci/sis7019.c:	writel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);
sound/pci/sis7019.c:			wave_base + SIS_WAVE_CHANNEL_CONTROL);
sound/pci/sis7019.c:	void __iomem *wave_base = timing->wave_base;
sound/pci/sis7019.c:		writel(0, wave_base + reg);
sound/pci/sis7019.c:	writel(SIS_WAVE_GENERAL_WAVE_VOLUME, wave_base + SIS_WAVE_GENERAL);
sound/pci/sis7019.c:	writel(delta << 16, wave_base + SIS_WAVE_GENERAL_ARTICULATION);
sound/pci/sis7019.c:			wave_base + SIS_WAVE_CHANNEL_CONTROL);
sound/pci/sis7019.c:	/* Don't attenuate any audio set for the wave amplifier.
sound/pci/sis7019.c:	/* Ensure that the wave engine is in normal operating mode.
sound/pci/sis7019.c:	/* We need 16K to store the internal wave engine state during a
sound/pci/sis7019.c:		voice->wave_base = SIS_WAVE_ADDR(sis->ioaddr, i);
sound/pci/trident/trident.c:		"{CHIC,True Sound 4Dwave},"
sound/pci/trident/trident.c:static int wavetable_size[SNDRV_CARDS] = {[0 ... (SNDRV_CARDS - 1)] = 8192};
sound/pci/trident/trident.c:module_param_array(wavetable_size, int, NULL, 0444);
sound/pci/trident/trident.c:MODULE_PARM_DESC(wavetable_size, "Maximum memory size in kB for wavetable synth.");
sound/pci/trident/trident.c:				      wavetable_size[dev],
sound/pci/trident/trident_main.c:    Description: wave & music volume control
sound/pci/trident/trident_main.c:	val = trident->musicvol_wavevol;
sound/pci/trident/trident_main.c:	val = trident->musicvol_wavevol;
sound/pci/trident/trident_main.c:	change = val != trident->musicvol_wavevol;
sound/pci/trident/trident_main.c:	outl(trident->musicvol_wavevol = val, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
sound/pci/trident/trident_main.c:static struct snd_kcontrol_new snd_trident_vol_wave_control __devinitdata =
sound/pci/trident/trident_main.c:		if ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_vol_wave_control, trident))) < 0)
sound/pci/trident/trident_main.c:		outl(trident->musicvol_wavevol = 0x00000000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
sound/pci/trident/trident_main.c:		outl(trident->musicvol_wavevol = 0xffff0000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
sound/pci/trident/trident_main.c:	/* reset the legacy configuration and whole audio/wavetable block */
sound/pci/trident/trident_main.c:	/* reset the legacy configuration and whole audio/wavetable block */
sound/pci/trident/trident_main.c:		       int max_wavetable_size,
sound/pci/trident/trident_main.c:	if (max_wavetable_size < 0 )
sound/pci/trident/trident_main.c:		max_wavetable_size = 0;
sound/pci/trident/trident_main.c:	trident->synth.max_size = max_wavetable_size * 1024;
sound/pci/trident/trident_main.c:	outl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));
sound/pci/korg1212/korg1212.c:                                       //    the card's current state. (or the wave device's
sound/pci/korg1212/korg1212.c:   K1212_CMDRET_BadDevice,             // the specified wave device was out of range
sound/pci/korg1212/korg1212.c:   K1212_CMDRET_BadFormat              // the specified wave format is unsupported
sound/pci/es1968.c: *	basic encodings of the data.  The wavecache is a storehouse for
sound/pci/es1968.c: *	data fetched over PCI by the wavecahche into analog data that
sound/pci/es1968.c: *	decide which wavecache gets the left or right channel.
sound/pci/es1968.c: *	the wavecache and PCI.  If its stereo, we mash it back into LRLR in
sound/pci/es1968.c: *	to have a 512 byte buffer sitting around in wavecache/memory.
sound/pci/es1968.c: *	The wavecache makes our life even more fun.  First off, it can
sound/pci/es1968.c: *	512 byte regions for the recording wavecaches.  This ends up
sound/pci/es1968.c: *	like the wave cache, maestro registers, etc.  Then we have beasts
sound/pci/es1968.c:#define ESM_APU_WAVE64K_PAGE_SHIFT	8	/* most 8bit of wave start offset */
sound/pci/es1968.c:/* reg 0x05 - wave start offset */
sound/pci/es1968.c:/* reg 0x06 - wave end offset */
sound/pci/es1968.c:/* reg 0x07 - wave loop length */
sound/pci/es1968.c:static void wave_set_register(struct es1968 *chip, u16 reg, u16 value)
sound/pci/es1968.c:static u16 wave_get_register(struct es1968 *chip, u16 reg)
sound/pci/es1968.c:/* set the wavecache control reg */
sound/pci/es1968.c:static void snd_es1968_program_wavecache(struct es1968 *chip, struct esschan *es,
sound/pci/es1968.c:	/* set the wavecache control reg */
sound/pci/es1968.c:	wave_set_register(chip, es->apu[channel] << 3, tmpval);
sound/pci/es1968.c:		snd_es1968_program_wavecache(chip, es, channel, es->memory->buf.addr, 0);
sound/pci/es1968.c:		/* Load the buffer into the wave engine */
sound/pci/es1968.c:	/* set the wavecache control reg */
sound/pci/es1968.c:	snd_es1968_program_wavecache(chip, es, channel, pa, 1);
sound/pci/es1968.c:	/* Load the buffer into the wave engine */
sound/pci/es1968.c:	wave_set_register(chip, apu << 3, (memory->buf.addr - 0x10) & 0xfff8);
sound/pci/es1968.c:	wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
sound/pci/es1968.c:	wave_set_register(chip, 0x01FD, chip->dma.addr >> 12);
sound/pci/es1968.c:	wave_set_register(chip, 0x01FE, chip->dma.addr >> 12);
sound/pci/es1968.c:	wave_set_register(chip, 0x01FF, chip->dma.addr >> 12);
sound/pci/es1968.c:	 * set up wavecache
sound/pci/es1968.c:	wave_set_register(chip, IDR7_WAVE_ROMRAM,
sound/pci/es1968.c:			  (wave_get_register(chip, IDR7_WAVE_ROMRAM) & 0xFF00));
sound/pci/es1968.c:	wave_set_register(chip, IDR7_WAVE_ROMRAM,
sound/pci/es1968.c:			  wave_get_register(chip, IDR7_WAVE_ROMRAM) | 0x100);
sound/pci/es1968.c:	wave_set_register(chip, IDR7_WAVE_ROMRAM,
sound/pci/es1968.c:			  wave_get_register(chip, IDR7_WAVE_ROMRAM) & ~0x200);
sound/pci/es1968.c:	wave_set_register(chip, IDR7_WAVE_ROMRAM,
sound/pci/es1968.c:			  wave_get_register(chip, IDR7_WAVE_ROMRAM) | ~0x400);
sound/pci/es1968.c:		wave_set_register(chip, 0x01FC, chip->dma.addr >> 12);
sound/oss/Kconfig:	  <file:Documentation/sound/oss/INSTALL.awe>. If you have an IBM Mwave
sound/oss/Kconfig:	  card, say Y here and read <file:Documentation/sound/oss/mwave>.
sound/oss/Makefile:obj-$(CONFIG_SOUND_WAVEARTIST)	+= waveartist.o
sound/oss/swarm_cs4297a.c:#define CS_WAVE_WRITE 	0x00000010	// write information for wave
sound/oss/swarm_cs4297a.c:#define CS_WAVE_READ 	0x00000020	// read information for wave
sound/oss/swarm_cs4297a.c:	// wave stuff   
sound/oss/waveartist.h: * linux/sound/oss/waveartist.h
sound/oss/waveartist.c: * linux/sound/oss/waveartist.c
sound/oss/waveartist.c: *		Added __init to waveartist_init()
sound/oss/waveartist.c:#include "waveartist.h"
sound/oss/waveartist.c:	const struct waveartist_mixer_info *mix;
sound/oss/waveartist.c:struct waveartist_mixer_info {
sound/oss/waveartist.c:static int		nr_waveartist_devs;
sound/oss/waveartist.c:static DEFINE_SPINLOCK(waveartist_lock);
sound/oss/waveartist.c:waveartist_set_ctlr(struct address_info *hw, unsigned char clear, unsigned char set)
sound/oss/waveartist.c:waveartist_iack(wavnc_info *devc)
sound/oss/waveartist.c:waveartist_sleep(int timeout_ms)
sound/oss/waveartist.c:waveartist_reset(wavnc_info *devc)
sound/oss/waveartist.c:	waveartist_set_ctlr(hw, -1, RESET);
sound/oss/waveartist.c:	waveartist_sleep(2);
sound/oss/waveartist.c:	waveartist_set_ctlr(hw, RESET, 0);
sound/oss/waveartist.c:waveartist_cmd(wavnc_info *devc,
sound/oss/waveartist.c:		printk("waveartist_cmd: cmd=");
sound/oss/waveartist.c:			printk("waveartist_cmd: resp=");
sound/oss/waveartist.c:			printk("waveartist_cmd: timed out\n");
sound/oss/waveartist.c:waveartist_cmd1(wavnc_info *devc, unsigned int cmd)
sound/oss/waveartist.c:	return waveartist_cmd(devc, 1, &cmd, 0, NULL);
sound/oss/waveartist.c:waveartist_cmd1_r(wavnc_info *devc, unsigned int cmd)
sound/oss/waveartist.c:	waveartist_cmd(devc, 1, &cmd, 1, &ret);
sound/oss/waveartist.c:waveartist_cmd2(wavnc_info *devc, unsigned int cmd, unsigned int arg)
sound/oss/waveartist.c:	return waveartist_cmd(devc, 2, vals, 1, vals);
sound/oss/waveartist.c:waveartist_cmd3(wavnc_info *devc, unsigned int cmd,
sound/oss/waveartist.c:	return waveartist_cmd(devc, 3, vals, 0, NULL);
sound/oss/waveartist.c:waveartist_getrev(wavnc_info *devc, char *rev)
sound/oss/waveartist.c:	waveartist_cmd(devc, 1, &cmd, 2, temp);
sound/oss/waveartist.c:static void waveartist_halt_output(int dev);
sound/oss/waveartist.c:static void waveartist_halt_input(int dev);
sound/oss/waveartist.c:static void waveartist_halt(int dev);
sound/oss/waveartist.c:static void waveartist_trigger(int dev, int state);
sound/oss/waveartist.c:waveartist_open(int dev, int mode)
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:		spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_trigger(dev, 0);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_close(int dev)
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_halt(dev);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_output_block(int dev, unsigned long buf, int __count, int intrflag)
sound/oss/waveartist.c:		printk("waveartist: output block, buf=0x%lx, count=0x%x...\n",
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_cmd2(devc, WACMD_OUTPUTSIZE, count);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_start_input(int dev, unsigned long buf, int __count, int intrflag)
sound/oss/waveartist.c:		printk("waveartist: start input, buf=0x%lx, count=0x%x...\n",
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_cmd2(devc, WACMD_INPUTSIZE, count);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_ioctl(int dev, unsigned int cmd, void __user * arg)
sound/oss/waveartist.c:waveartist_get_speed(wavnc_port_info *portc)
sound/oss/waveartist.c:waveartist_get_bits(wavnc_port_info *portc)
sound/oss/waveartist.c:waveartist_prepare_for_input(int dev, int bsize, int bcount)
sound/oss/waveartist.c:	speed = waveartist_get_speed(portc);
sound/oss/waveartist.c:	bits  = waveartist_get_bits(portc);
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_INPUTFORMAT, bits))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_INPUTCHANNELS, portc->channels))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting record "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_INPUTSPEED, speed))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the record "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_INPUTDMA, 1))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the record "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_INPUTFORMAT, bits))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the record "
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_halt_input(dev);
sound/oss/waveartist.c:waveartist_prepare_for_output(int dev, int bsize, int bcount)
sound/oss/waveartist.c:	speed = waveartist_get_speed(portc);
sound/oss/waveartist.c:	bits  = waveartist_get_bits(portc);
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_OUTPUTSPEED, speed) &&
sound/oss/waveartist.c:	    waveartist_cmd2(devc, WACMD_OUTPUTSPEED, speed))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the playback "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_OUTPUTCHANNELS, portc->channels))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the playback "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_OUTPUTDMA, 0))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the playback "
sound/oss/waveartist.c:	if (waveartist_cmd2(devc, WACMD_OUTPUTFORMAT, bits))
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: error setting the playback "
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_halt_output(dev);
sound/oss/waveartist.c:waveartist_halt(int dev)
sound/oss/waveartist.c:		waveartist_halt_output(dev);
sound/oss/waveartist.c:		waveartist_halt_input(dev);
sound/oss/waveartist.c:waveartist_halt_input(int dev)
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_cmd1(devc, WACMD_INPUTSTOP);
sound/oss/waveartist.c:		waveartist_iack(devc);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_halt_output(int dev)
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	waveartist_cmd1(devc, WACMD_OUTPUTSTOP);
sound/oss/waveartist.c:		waveartist_iack(devc);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_trigger(int dev, int state)
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:		waveartist_cmd1(devc, WACMD_INPUTSTART);
sound/oss/waveartist.c:		waveartist_cmd1(devc, WACMD_OUTPUTSTART);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:waveartist_set_speed(int dev, int arg)
sound/oss/waveartist.c:waveartist_set_channels(int dev, short arg)
sound/oss/waveartist.c:waveartist_set_bits(int dev, unsigned int arg)
sound/oss/waveartist.c:static struct audio_driver waveartist_audio_driver = {
sound/oss/waveartist.c:	.open			= waveartist_open,
sound/oss/waveartist.c:	.close			= waveartist_close,
sound/oss/waveartist.c:	.output_block		= waveartist_output_block,
sound/oss/waveartist.c:	.start_input		= waveartist_start_input,
sound/oss/waveartist.c:	.ioctl			= waveartist_ioctl,
sound/oss/waveartist.c:	.prepare_for_input	= waveartist_prepare_for_input,
sound/oss/waveartist.c:	.prepare_for_output	= waveartist_prepare_for_output,
sound/oss/waveartist.c:	.halt_io		= waveartist_halt,
sound/oss/waveartist.c:	.halt_input		= waveartist_halt_input,
sound/oss/waveartist.c:	.halt_output		= waveartist_halt_output,
sound/oss/waveartist.c:	.trigger		= waveartist_trigger,
sound/oss/waveartist.c:	.set_speed		= waveartist_set_speed,
sound/oss/waveartist.c:	.set_bits		= waveartist_set_bits,
sound/oss/waveartist.c:	.set_channels		= waveartist_set_channels
sound/oss/waveartist.c:waveartist_intr(int irq, void *dev_id)
sound/oss/waveartist.c:	spin_lock(&waveartist_lock);
sound/oss/waveartist.c:		printk("waveartist_intr: stat=%02x, irqstat=%02x\n",
sound/oss/waveartist.c:		waveartist_iack(devc);
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: unexpected interrupt\n");
sound/oss/waveartist.c:			printk(KERN_WARNING "waveartist: Unknown interrupt\n");
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: Unexpected SB interrupt...\n");
sound/oss/waveartist.c:	spin_unlock(&waveartist_lock);
sound/oss/waveartist.c:waveartist_mixer_update(wavnc_info *devc, int whichDev)
sound/oss/waveartist.c:		left  = waveartist_cmd1_r(devc, WACMD_GET_LEVEL |
sound/oss/waveartist.c:		right = waveartist_cmd1_r(devc, WACMD_GET_LEVEL |
sound/oss/waveartist.c:		waveartist_cmd3(devc, WACMD_SET_MIXER, left, right);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_LEVEL,
sound/oss/waveartist.c:			waveartist_cmd3(devc, 0x0100 | WACMD_SET_LEVEL,
sound/oss/waveartist.c:waveartist_set_adc_mux(wavnc_info *devc, char left_dev, char right_dev)
sound/oss/waveartist.c:	reg_08 = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x0800);
sound/oss/waveartist.c:	reg_09 = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x0900);
sound/oss/waveartist.c:	waveartist_cmd3(devc, WACMD_SET_MIXER, reg_08, reg_09);
sound/oss/waveartist.c:waveartist_select_input(wavnc_info *devc, unsigned int recmask,
sound/oss/waveartist.c:waveartist_decode_mixer(wavnc_info *devc, int dev, unsigned char lev_l,
sound/oss/waveartist.c:static int waveartist_get_mixer(wavnc_info *devc, int dev)
sound/oss/waveartist.c:static const struct waveartist_mixer_info waveartist_mixer = {
sound/oss/waveartist.c:	.select_input	= waveartist_select_input,
sound/oss/waveartist.c:	.decode_mixer	= waveartist_decode_mixer,
sound/oss/waveartist.c:	.get_mixer	= waveartist_get_mixer,
sound/oss/waveartist.c:waveartist_set_recmask(wavnc_info *devc, unsigned int recmask)
sound/oss/waveartist.c:	waveartist_set_adc_mux(devc, dev_l, dev_r);
sound/oss/waveartist.c:waveartist_set_mixer(wavnc_info *devc, int dev, unsigned int level)
sound/oss/waveartist.c:		waveartist_mixer_update(devc, dev);
sound/oss/waveartist.c:waveartist_mixer_ioctl(int dev, unsigned int cmd, void __user * arg)
sound/oss/waveartist.c:			waveartist_set_recmask(devc, val);
sound/oss/waveartist.c:				ret = waveartist_set_mixer(devc, nr, val);
sound/oss/waveartist.c:static struct mixer_operations waveartist_mixer_operations =
sound/oss/waveartist.c:	.ioctl	= waveartist_mixer_ioctl
sound/oss/waveartist.c:waveartist_mixer_reset(wavnc_info *devc)
sound/oss/waveartist.c:	waveartist_cmd1(devc, WACMD_RST_MIXER);
sound/oss/waveartist.c:	waveartist_cmd3(devc, WACMD_SET_MIXER, 0x9800, 0xa836);
sound/oss/waveartist.c:	waveartist_cmd3(devc, WACMD_SET_MIXER, 0x4c00, 0x8c00);
sound/oss/waveartist.c:	waveartist_cmd3(devc, WACMD_SET_MIXER, 0x2801, 0x6800);
sound/oss/waveartist.c:	waveartist_set_recmask(devc, 0);
sound/oss/waveartist.c:		waveartist_mixer_update(devc, i);
sound/oss/waveartist.c:static int __init waveartist_init(wavnc_info *devc)
sound/oss/waveartist.c:	if (waveartist_reset(devc))
sound/oss/waveartist.c:	if (waveartist_getrev(devc, rev)) {
sound/oss/waveartist.c:			&waveartist_audio_driver, sizeof(struct audio_driver),
sound/oss/waveartist.c:	waveartist_mixer_reset(devc);
sound/oss/waveartist.c:	waveartist_iack(devc);
sound/oss/waveartist.c:	if (request_irq(devc->hw.irq, waveartist_intr, 0, devc->hw.name, devc) < 0) {
sound/oss/waveartist.c:	waveartist_set_ctlr(&devc->hw, 0, DMA1_IE | DMA0_IE);
sound/oss/waveartist.c:				&waveartist_mixer_operations,
sound/oss/waveartist.c:static int __init probe_waveartist(struct address_info *hw_config)
sound/oss/waveartist.c:	wavnc_info *devc = &adev_info[nr_waveartist_devs];
sound/oss/waveartist.c:	if (nr_waveartist_devs >= MAX_AUDIO_DEV) {
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: too many audio devices\n");
sound/oss/waveartist.c:attach_waveartist(struct address_info *hw, const struct waveartist_mixer_info *mix)
sound/oss/waveartist.c:	wavnc_info *devc = &adev_info[nr_waveartist_devs];
sound/oss/waveartist.c:	devc->dev_no = waveartist_init(devc);
sound/oss/waveartist.c:			vnc_timer.data     = nr_waveartist_devs;
sound/oss/waveartist.c:		nr_waveartist_devs += 1;
sound/oss/waveartist.c:static void __exit unload_waveartist(struct address_info *hw)
sound/oss/waveartist.c:	for (i = 0; i < nr_waveartist_devs; i++)
sound/oss/waveartist.c:		waveartist_set_ctlr(&devc->hw, DMA1_IE|DMA0_IE, 0);
sound/oss/waveartist.c:		nr_waveartist_devs -= 1;
sound/oss/waveartist.c:		for (; i < nr_waveartist_devs; i++)
sound/oss/waveartist.c:		printk(KERN_WARNING "waveartist: can't find device "
sound/oss/waveartist.c:	left  = waveartist_cmd1_r(devc, WACMD_GET_LEVEL);
sound/oss/waveartist.c:	right = waveartist_cmd1_r(devc, WACMD_GET_LEVEL | 0x400);
sound/oss/waveartist.c:	waveartist_cmd3(devc, WACMD_SET_MIXER, left, right);
sound/oss/waveartist.c:	spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:	spin_unlock_irqrestore(&waveartist_lock,flags);
sound/oss/waveartist.c:		waveartist_cmd1(devc, WACMD_SET_MONO); /* left */
sound/oss/waveartist.c:		waveartist_cmd1(devc, WACMD_SET_MONO); /* left */
sound/oss/waveartist.c:		waveartist_cmd1(devc, WACMD_SET_MONO | 0x100);	/* right */
sound/oss/waveartist.c:static const struct waveartist_mixer_info netwinder_mixer = {
sound/oss/waveartist.c:			waveartist_set_recmask(devc, recmask);
sound/oss/waveartist.c:		waveartist_set_mixer(devc, SOUND_MIXER_VOLUME,
sound/oss/waveartist.c:			waveartist_cmd1(devc, 0x16);
sound/oss/waveartist.c:			waveartist_cmd1(devc, 0x18);
sound/oss/waveartist.c:	/* private ioctl to allow bulk access to waveartist */
sound/oss/waveartist.c:			waveartist_mixer_reset(devc);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[0], mixer_reg[4]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[1], mixer_reg[5]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[2], mixer_reg[6]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[3], mixer_reg[7]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_MIXER, mixer_reg[8], mixer_reg[9]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_LEVEL, mixer_reg[10], mixer_reg[11]);
sound/oss/waveartist.c:			waveartist_cmd3(devc, WACMD_SET_LEVEL, mixer_reg[12], mixer_reg[13]);
sound/oss/waveartist.c:			spin_lock_irqsave(&waveartist_lock, flags);
sound/oss/waveartist.c:				waveartist_cmd(devc, 1, &i, 1, mixer_reg + (i >> 8));
sound/oss/waveartist.c:			spin_unlock_irqrestore(&waveartist_lock, flags);
sound/oss/waveartist.c:static int __init init_waveartist(void)
sound/oss/waveartist.c:	const struct waveartist_mixer_info *mix;
sound/oss/waveartist.c:	mix = &waveartist_mixer;
sound/oss/waveartist.c:	if (!probe_waveartist(&cfg))
sound/oss/waveartist.c:	attach_waveartist(&cfg, mix);
sound/oss/waveartist.c:static void __exit cleanup_waveartist(void)
sound/oss/waveartist.c:		unload_waveartist(&cfg);
sound/oss/waveartist.c:module_init(init_waveartist);
sound/oss/waveartist.c:module_exit(cleanup_waveartist);
sound/oss/waveartist.c:static int __init setup_waveartist(char *str)
sound/oss/waveartist.c:__setup("waveartist=", setup_waveartist);
sound/oss/CHANGELOG:- Disabled MIDI input with GUS PnP (Interwave). There seems to be constant
sound/oss/CHANGELOG:- Fixed random protection fault in gus_wave.c
sound/oss/CHANGELOG:- Fixed a bug in the compute_and_set_volume in gus_wave.c
sound/oss/ad1848_mixer.h:static mixer_ents iwave_mix_devices[32] = {
sound/oss/ad1848_mixer.h:	/* This is external wavetable */
sound/oss/ad1848.c:			devc->mix_devices = &(iwave_mix_devices[0]);
sound/oss/ad1848.c:		{		/* Some magic Interwave specific initialization */
sound/oss/ad1848.c:	int interwave = 0;
sound/oss/ad1848.c:			interwave = 1;
sound/oss/ad1848.c:					if (interwave)
sound/soc/davinci/davinci-i2s.c:			/* symmetric waveforms */
sound/core/seq/seq_midi_emul.c: *  Based on awe_wave.c by Takashi Iwai
Fichier binaire toolchain/share/doc/gcc-linaro-arm-linux-gnueabihf/html/gcc/gccinstall.pdf concordant
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/asequencer.h:#define SNDRV_SEQ_PORT_TYPE_SYNTH	(1<<10)	/* Synth device (no MIDI compatible - direct wavetable) */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/asound_fm.h:	unsigned char waveform;		/* 3 bits: waveform shape */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/asound.h:	SNDRV_HWDEP_IFACE_EMUX_WAVETABLE, /* EmuX wavetable */	
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h:/* wave table envelope & effect parameters to control EMU8000 */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h:/* wave table parameters: 92 bytes */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h: * sample wave information
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h:/* wave table sample header: 32 bytes */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h:#define SNDRV_SFNT_SAMPLE_8BITS		1	/* wave data is 8bits */
toolchain/arm-linux-gnueabihf/libc/usr/include/sound/sfnt_info.h:#define SNDRV_SFNT_SAMPLE_UNSIGNED	2	/* wave data is unsigned */
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/soundcard.h:#define WAVE_16_BITS	0x01	/* bit 0 = 8 or 16 bit wave data. */
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/soundcard.h:		int len;	/* Size of the wave data in bytes */
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/soundcard.h:		char data[1];	/* The waveform data starts here */
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/soundcard.h: *	For wave table use struct patch_info. Initialize the key field
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/input.h: * @waveform: kind of the effect (wave)
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/input.h: * @period: period of the wave (ms)
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/input.h: * @offset: mean value of the wave (roughly)
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/input.h: * Known waveforms - FF_SQUARE, FF_TRIANGLE, FF_SINE, FF_SAW_UP,
toolchain/arm-linux-gnueabihf/libc/usr/include/linux/input.h:	__u16 waveform;
usr/wavenand_initramfs_files/ics_init/init.wave.rc:import init.wave.usb.rc
usr/wavenand_initramfs_files/ics_init/init.wave.rc: service wave-ril-daemon /system/bin/rild
